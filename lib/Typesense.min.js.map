{"version":3,"sources":["/home/fanis/code/typesense/typesense-js/lib/Typesense.min.js","../src/Typesense/Configuration.ts","../src/Typesense/Errors/index.ts","../src/Typesense/Errors/TypesenseError.ts","../src/Typesense/Errors/HTTPError.ts","../src/Typesense/Errors/MissingConfigurationError.ts","../src/Typesense/Errors/ObjectAlreadyExists.ts","../src/Typesense/Errors/ObjectNotFound.ts","../src/Typesense/Errors/ObjectUnprocessable.ts","../src/Typesense/Errors/RequestMalformed.ts","../src/Typesense/Errors/RequestUnauthorized.ts","../src/Typesense/Errors/ServerError.ts","../src/Typesense/Errors/ImportError.ts","../src/Typesense/ApiCall.ts","../src/Typesense/Documents.ts","../src/Typesense/MultiSearch.ts"],"names":["Errors_exports","__export","HTTPError","ImportError","MissingConfigurationError","ObjectAlreadyExists","ObjectNotFound","ObjectUnprocessable","RequestMalformed","RequestUnauthorized","ServerError","TypesenseError","message","importResults","Configuration","options","node","logger","key","array","i","j","APIKEYHEADERNAME","HEALTHY","UNHEALTHY","isNodeJSEnvironment","ApiCall","configuration","endpoint","queryParameters","abortSignal","responseType","bodyParameters","additionalHeaders","requestType","skipConnectionTimeout","enableKeepAlive","requestNumber","lastException"],"mappings":"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","file":"/home/fanis/code/typesense/typesense-js/lib/Typesense.min.js","sourcesContent":[null,"import * as logger from \"loglevel\";\nimport { Logger, LogLevelDesc } from \"loglevel\";\nimport { MissingConfigurationError } from \"./Errors\";\nimport type { Agent as HTTPAgent } from \"http\";\nimport type { Agent as HTTPSAgent } from \"https\";\n\nexport interface NodeConfiguration {\n  host: string;\n  port: number;\n  protocol: string;\n  path?: string;\n  url?: string;\n}\n\nexport interface NodeConfigurationWithHostname {\n  host: string;\n  port: number;\n  protocol: string;\n  path?: string;\n}\n\nexport interface NodeConfigurationWithUrl {\n  url: string;\n}\n\nexport interface ConfigurationOptions {\n  apiKey: string;\n  nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  randomizeNodes?: boolean;\n  /**\n   * @deprecated\n   * masterNode is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  masterNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  /**\n   * @deprecated\n   * readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  readReplicaNodes?:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  connectionTimeoutSeconds?: number;\n  timeoutSeconds?: number;\n  healthcheckIntervalSeconds?: number;\n  numRetries?: number;\n  retryIntervalSeconds?: number;\n  sendApiKeyAsQueryParam?: boolean | undefined;\n  useServerSideSearchCache?: boolean;\n  cacheSearchResultsForSeconds?: number;\n  additionalHeaders?: Record<string, string>;\n\n  logLevel?: LogLevelDesc;\n  logger?: Logger;\n\n  /**\n   * Set a custom HTTP Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPAgent } = require(\"http\");\n   *      ...\n   *      httpAgent: new HTTPAgent({ keepAlive: true }),\n   * @type {HTTPAgent}\n   */\n  httpAgent?: HTTPAgent;\n\n  /**\n   * Set a custom HTTPS Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPSAgent } = require(\"https\");\n   *      ...\n   *      httpsAgent: new HTTPSAgent({ keepAlive: true }),\n   * @type {HTTPSAgent}\n   */\n  httpsAgent?: HTTPSAgent;\n\n  /**\n   * Set a custom paramsSerializer\n   *\n   * See axios documentation for more information on how to use this parameter: https://axios-http.com/docs/req_config\n   *  This is helpful for handling React Native issues like this: https://github.com/axios/axios/issues/6102#issuecomment-2085301397\n   * @type {any}\n   */\n  paramsSerializer?: any;\n}\n\nexport default class Configuration {\n  readonly nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  readonly nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  readonly connectionTimeoutSeconds: number;\n  readonly healthcheckIntervalSeconds: number;\n  readonly numRetries: number;\n  readonly retryIntervalSeconds: number;\n  readonly apiKey: string;\n  readonly sendApiKeyAsQueryParam?: boolean;\n  readonly cacheSearchResultsForSeconds: number;\n  readonly useServerSideSearchCache: boolean;\n  readonly logger: Logger;\n  readonly logLevel: LogLevelDesc;\n  readonly additionalHeaders?: Record<string, string>;\n  readonly httpAgent?: HTTPAgent;\n  readonly httpsAgent?: HTTPSAgent;\n  readonly paramsSerializer?: any;\n\n  constructor(options: ConfigurationOptions) {\n    this.nodes = options.nodes || [];\n    this.nodes = this.nodes\n      .map((node) => this.setDefaultPathInNode(node))\n      .map((node) => this.setDefaultPortInNode(node))\n      .map((node) => ({ ...node })) as NodeConfiguration[]; // Make a deep copy\n\n    if (options.randomizeNodes == null) {\n      options.randomizeNodes = true;\n    }\n\n    if (options.randomizeNodes === true) {\n      this.shuffleArray(this.nodes);\n    }\n\n    this.nearestNode = options.nearestNode;\n    this.nearestNode = this.setDefaultPathInNode(this.nearestNode);\n    this.nearestNode = this.setDefaultPortInNode(this.nearestNode);\n\n    this.connectionTimeoutSeconds =\n      options.connectionTimeoutSeconds || options.timeoutSeconds || 5;\n    this.healthcheckIntervalSeconds = options.healthcheckIntervalSeconds || 60;\n    this.numRetries =\n      options.numRetries ||\n      this.nodes.length + (this.nearestNode == null ? 0 : 1) ||\n      3;\n    this.retryIntervalSeconds = options.retryIntervalSeconds || 0.1;\n\n    this.apiKey = options.apiKey;\n    this.sendApiKeyAsQueryParam = options.sendApiKeyAsQueryParam; // We will set a default for this in Client and SearchClient\n\n    this.cacheSearchResultsForSeconds =\n      options.cacheSearchResultsForSeconds || 0; // Disable client-side cache by default\n    this.useServerSideSearchCache = options.useServerSideSearchCache || false;\n\n    this.logger = options.logger || logger;\n    this.logLevel = options.logLevel || \"warn\";\n    this.logger.setLevel(this.logLevel);\n\n    this.additionalHeaders = options.additionalHeaders;\n\n    this.httpAgent = options.httpAgent;\n    this.httpsAgent = options.httpsAgent;\n\n    this.paramsSerializer = options.paramsSerializer;\n\n    this.showDeprecationWarnings(options);\n    this.validate();\n  }\n\n  validate(): boolean {\n    if (this.nodes == null || this.nodes.length === 0 || this.validateNodes()) {\n      throw new MissingConfigurationError(\n        \"Ensure that nodes[].protocol, nodes[].host and nodes[].port are set\",\n      );\n    }\n\n    if (\n      this.nearestNode != null &&\n      this.isNodeMissingAnyParameters(this.nearestNode)\n    ) {\n      throw new MissingConfigurationError(\n        \"Ensure that nearestNodes.protocol, nearestNodes.host and nearestNodes.port are set\",\n      );\n    }\n\n    if (this.apiKey == null) {\n      throw new MissingConfigurationError(\"Ensure that apiKey is set\");\n    }\n\n    return true;\n  }\n\n  private validateNodes(): boolean {\n    return this.nodes.some((node) => {\n      return this.isNodeMissingAnyParameters(node);\n    });\n  }\n\n  private isNodeMissingAnyParameters(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl,\n  ): boolean {\n    return (\n      ![\"protocol\", \"host\", \"port\", \"path\"].every((key) => {\n        return node.hasOwnProperty(key);\n      }) && node[\"url\"] == null\n    );\n  }\n\n  private setDefaultPathInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined,\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (node != null && !node.hasOwnProperty(\"path\")) {\n      node[\"path\"] = \"\";\n    }\n    return node;\n  }\n\n  private setDefaultPortInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined,\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (\n      node != null &&\n      !node.hasOwnProperty(\"port\") &&\n      node.hasOwnProperty(\"protocol\")\n    ) {\n      switch (node[\"protocol\"]) {\n        case \"https\":\n          node[\"port\"] = 443;\n          break;\n        case \"http\":\n          node[\"port\"] = 80;\n          break;\n      }\n    }\n    return node;\n  }\n\n  private showDeprecationWarnings(options: ConfigurationOptions): void {\n    if (options.timeoutSeconds) {\n      this.logger.warn(\n        \"Deprecation warning: timeoutSeconds is now renamed to connectionTimeoutSeconds\",\n      );\n    }\n    if (options.masterNode) {\n      this.logger.warn(\n        \"Deprecation warning: masterNode is now consolidated to nodes, starting with Typesense Server v0.12\",\n      );\n    }\n    if (options.readReplicaNodes) {\n      this.logger.warn(\n        \"Deprecation warning: readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12\",\n      );\n    }\n  }\n\n  private shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n}\n","import HTTPError from \"./HTTPError\";\nimport MissingConfigurationError from \"./MissingConfigurationError\";\nimport ObjectAlreadyExists from \"./ObjectAlreadyExists\";\nimport ObjectNotFound from \"./ObjectNotFound\";\nimport ObjectUnprocessable from \"./ObjectUnprocessable\";\nimport RequestMalformed from \"./RequestMalformed\";\nimport RequestUnauthorized from \"./RequestUnauthorized\";\nimport ServerError from \"./ServerError\";\nimport ImportError from \"./ImportError\";\nimport TypesenseError from \"./TypesenseError\";\n\nexport {\n  HTTPError,\n  MissingConfigurationError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n  TypesenseError,\n  ImportError,\n};\n","export default class TypesenseError extends Error {\n  httpStatus?: number;\n\n  // Source: https://stackoverflow.com/a/58417721/123545\n  constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class HTTPError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class MissingConfigurationError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectAlreadyExists extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectNotFound extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectUnprocessable extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestMalformed extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestUnauthorized extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ServerError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\nimport { ImportResponse } from \"../Documents\";\n\nexport default class ImportError extends TypesenseError {\n  importResults: ImportResponse[];\n  constructor(message: string, importResults: ImportResponse[]) {\n    super(message);\n    this.importResults = importResults;\n  }\n}\n","import axios, { AxiosRequestConfig, AxiosResponse, Method } from \"axios\";\nimport { Logger } from \"loglevel\";\nimport {\n  HTTPError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n} from \"./Errors\";\nimport TypesenseError from \"./Errors/TypesenseError\";\nimport Configuration, { NodeConfiguration } from \"./Configuration\";\nimport { Agent as HTTPAgent } from \"http\";\nimport { Agent as HTTPSAgent } from \"https\";\n\nconst APIKEYHEADERNAME = \"X-TYPESENSE-API-KEY\";\nconst HEALTHY = true;\nconst UNHEALTHY = false;\n\ninterface Node extends NodeConfiguration {\n  isHealthy: boolean;\n  index: string | number;\n}\n\nconst isNodeJSEnvironment =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nexport default class ApiCall {\n  private readonly apiKey: string;\n  private readonly nodes: Node[];\n  private readonly nearestNode: Node;\n  private readonly connectionTimeoutSeconds: number;\n  private readonly healthcheckIntervalSeconds: number;\n  private readonly retryIntervalSeconds: number;\n  private readonly sendApiKeyAsQueryParam?: boolean;\n  private readonly numRetriesPerRequest: number;\n  private readonly additionalUserHeaders?: Record<string, string>;\n\n  private readonly logger: Logger;\n  private currentNodeIndex: number;\n\n  constructor(private configuration: Configuration) {\n    this.apiKey = this.configuration.apiKey;\n    this.nodes =\n      this.configuration.nodes == null\n        ? this.configuration.nodes\n        : JSON.parse(JSON.stringify(this.configuration.nodes)); // Make a copy, since we'll be adding additional metadata to the nodes\n    this.nearestNode =\n      this.configuration.nearestNode == null\n        ? this.configuration.nearestNode\n        : JSON.parse(JSON.stringify(this.configuration.nearestNode));\n    this.connectionTimeoutSeconds = this.configuration.connectionTimeoutSeconds;\n    this.healthcheckIntervalSeconds =\n      this.configuration.healthcheckIntervalSeconds;\n    this.numRetriesPerRequest = this.configuration.numRetries;\n    this.retryIntervalSeconds = this.configuration.retryIntervalSeconds;\n    this.sendApiKeyAsQueryParam = this.configuration.sendApiKeyAsQueryParam;\n    this.additionalUserHeaders = this.configuration.additionalHeaders;\n\n    this.logger = this.configuration.logger;\n\n    this.initializeMetadataForNodes();\n    this.currentNodeIndex = -1;\n  }\n\n  async get<T>(\n    endpoint: string,\n    queryParameters: any = {},\n    {\n      abortSignal = null,\n      responseType = undefined,\n    }: {\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n    } = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"get\", endpoint, {\n      queryParameters,\n      abortSignal,\n      responseType,\n    });\n  }\n\n  async delete<T>(endpoint: string, queryParameters: any = {}): Promise<T> {\n    return this.performRequest<T>(\"delete\", endpoint, { queryParameters });\n  }\n\n  async post<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n    additionalHeaders: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"post\", endpoint, {\n      queryParameters,\n      bodyParameters,\n      additionalHeaders,\n    });\n  }\n\n  async put<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"put\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async patch<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"patch\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async performRequest<T>(\n    requestType: Method,\n    endpoint: string,\n    {\n      queryParameters = null,\n      bodyParameters = null,\n      additionalHeaders = {},\n      abortSignal = null,\n      responseType = undefined,\n      skipConnectionTimeout = false,\n      enableKeepAlive = undefined,\n    }: {\n      queryParameters?: any;\n      bodyParameters?: any;\n      additionalHeaders?: any;\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n      skipConnectionTimeout?: boolean;\n      enableKeepAlive?: boolean | undefined;\n    },\n  ): Promise<T> {\n    this.configuration.validate();\n\n    const requestNumber = Date.now();\n    let lastException;\n    this.logger.debug(\n      `Request #${requestNumber}: Performing ${requestType.toUpperCase()} request: ${endpoint}`,\n    );\n    for (\n      let numTries = 1;\n      numTries <= this.numRetriesPerRequest + 1;\n      numTries++\n    ) {\n      const node = this.getNextNode(requestNumber);\n      this.logger.debug(\n        `Request #${requestNumber}: Attempting ${requestType.toUpperCase()} request Try #${numTries} to Node ${\n          node.index\n        }`,\n      );\n\n      if (abortSignal && abortSignal.aborted) {\n        return Promise.reject(new Error(\"Request aborted by caller.\"));\n      }\n\n      let abortListener;\n\n      try {\n        const requestOptions: AxiosRequestConfig = {\n          method: requestType,\n          url: this.uriFor(endpoint, node),\n          headers: Object.assign(\n            {},\n            this.defaultHeaders(),\n            additionalHeaders,\n            this.additionalUserHeaders,\n          ),\n          maxContentLength: Infinity,\n          maxBodyLength: Infinity,\n          responseType,\n          validateStatus: (status) => {\n            /* Override default validateStatus, which only considers 2xx a success.\n                In our case, if the server returns any HTTP code, we will handle it below.\n                We do this to be able to raise custom errors based on response code.\n             */\n            return status > 0;\n          },\n          transformResponse: [\n            (data, headers) => {\n              let transformedData = data;\n              if (\n                headers !== undefined &&\n                typeof data === \"string\" &&\n                headers[\"content-type\"] &&\n                headers[\"content-type\"].startsWith(\"application/json\")\n              ) {\n                transformedData = JSON.parse(data);\n              }\n              return transformedData;\n            },\n          ],\n        };\n\n        if (skipConnectionTimeout !== true) {\n          requestOptions.timeout = this.connectionTimeoutSeconds * 1000;\n        }\n\n        if (queryParameters && Object.keys(queryParameters).length !== 0) {\n          requestOptions.params = queryParameters;\n        }\n\n        if (this.sendApiKeyAsQueryParam) {\n          requestOptions.params = requestOptions.params || {};\n          requestOptions.params[\"x-typesense-api-key\"] = this.apiKey;\n        }\n\n        if (this.configuration.httpAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpAgent`,\n          );\n          requestOptions.httpAgent = this.configuration.httpAgent;\n        } else if (enableKeepAlive === true) {\n          if (!isNodeJSEnvironment) {\n            this.logger.warn(\n              `Request #${requestNumber}: Cannot use custom httpAgent in a browser environment to enable keepAlive`,\n            );\n          } else {\n            this.logger.debug(`Request #${requestNumber}: Enabling KeepAlive`);\n            requestOptions.httpAgent = new HTTPAgent({ keepAlive: true });\n          }\n        }\n\n        if (this.configuration.httpsAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpsAgent`,\n          );\n          requestOptions.httpsAgent = this.configuration.httpsAgent;\n        } else if (enableKeepAlive === true) {\n          if (!isNodeJSEnvironment) {\n            this.logger.warn(\n              `Request #${requestNumber}: Cannot use custom httpAgent in a browser environment to enable keepAlive`,\n            );\n          } else {\n            this.logger.debug(`Request #${requestNumber}: Enabling keepAlive`);\n            requestOptions.httpsAgent = new HTTPSAgent({ keepAlive: true });\n          }\n        }\n\n        if (this.configuration.paramsSerializer) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom paramsSerializer`,\n          );\n          requestOptions.paramsSerializer = this.configuration.paramsSerializer;\n        }\n\n        if (\n          bodyParameters &&\n          ((typeof bodyParameters === \"string\" &&\n            bodyParameters.length !== 0) ||\n            (typeof bodyParameters === \"object\" &&\n              Object.keys(bodyParameters).length !== 0))\n        ) {\n          requestOptions.data = bodyParameters;\n        }\n\n        // Translate from user-provided AbortController to the Axios request cancel mechanism.\n        if (abortSignal) {\n          const cancelToken = axios.CancelToken;\n          const source = cancelToken.source();\n          abortListener = () => source.cancel();\n          abortSignal.addEventListener(\"abort\", abortListener);\n          requestOptions.cancelToken = source.token;\n        }\n\n        const response = await axios(requestOptions);\n        if (response.status >= 1 && response.status <= 499) {\n          // Treat any status code > 0 and < 500 to be an indication that node is healthy\n          // We exclude 0 since some clients return 0 when request fails\n          this.setNodeHealthcheck(node, HEALTHY);\n        }\n        this.logger.debug(\n          `Request #${requestNumber}: Request to Node ${node.index} was made. Response Code was ${response.status}.`,\n        );\n\n        if (response.status >= 200 && response.status < 300) {\n          // If response is 2xx return a resolved promise\n          return Promise.resolve(response.data);\n        } else if (response.status < 500) {\n          // Next, if response is anything but 5xx, don't retry, return a custom error\n          return Promise.reject(\n            this.customErrorForResponse(response, response.data?.message),\n          );\n        } else {\n          // Retry all other HTTP errors (HTTPStatus > 500)\n          // This will get caught by the catch block below\n          throw this.customErrorForResponse(response, response.data?.message);\n        }\n      } catch (error: any) {\n        // This block handles retries for HTTPStatus > 500 and network layer issues like connection timeouts\n        this.setNodeHealthcheck(node, UNHEALTHY);\n        lastException = error;\n        this.logger.warn(\n          `Request #${requestNumber}: Request to Node ${\n            node.index\n          } failed due to \"${error.code} ${error.message}${\n            error.response == null\n              ? \"\"\n              : \" - \" + JSON.stringify(error.response?.data)\n          }\"`,\n        );\n        // this.logger.debug(error.stack)\n        this.logger.warn(\n          `Request #${requestNumber}: Sleeping for ${this.retryIntervalSeconds}s and then retrying request...`,\n        );\n        await this.timer(this.retryIntervalSeconds);\n      } finally {\n        if (abortSignal && abortListener) {\n          abortSignal.removeEventListener(\"abort\", abortListener);\n        }\n      }\n    }\n    this.logger.debug(\n      `Request #${requestNumber}: No retries left. Raising last error`,\n    );\n    return Promise.reject(lastException);\n  }\n\n  // Attempts to find the next healthy node, looping through the list of nodes once.\n  //   But if no healthy nodes are found, it will just return the next node, even if it's unhealthy\n  //     so we can try the request for good measure, in case that node has become healthy since\n  getNextNode(requestNumber = 0): Node {\n    // Check if nearestNode is set and is healthy, if so return it\n    if (this.nearestNode != null) {\n      this.logger.debug(\n        `Request #${requestNumber}: Nodes Health: Node ${\n          this.nearestNode.index\n        } is ${this.nearestNode.isHealthy === true ? \"Healthy\" : \"Unhealthy\"}`,\n      );\n      if (\n        this.nearestNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(this.nearestNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${this.nearestNode.index}`,\n        );\n        return this.nearestNode;\n      }\n      this.logger.debug(\n        `Request #${requestNumber}: Falling back to individual nodes`,\n      );\n    }\n\n    // Fallback to nodes as usual\n    this.logger.debug(\n      `Request #${requestNumber}: Nodes Health: ${this.nodes\n        .map(\n          (node) =>\n            `Node ${node.index} is ${\n              node.isHealthy === true ? \"Healthy\" : \"Unhealthy\"\n            }`,\n        )\n        .join(\" || \")}`,\n    );\n    let candidateNode: Node = this.nodes[0];\n    for (let i = 0; i <= this.nodes.length; i++) {\n      this.currentNodeIndex = (this.currentNodeIndex + 1) % this.nodes.length;\n      candidateNode = this.nodes[this.currentNodeIndex];\n      if (\n        candidateNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(candidateNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${candidateNode.index}`,\n        );\n        return candidateNode;\n      }\n    }\n\n    // None of the nodes are marked healthy, but some of them could have become healthy since last health check.\n    //  So we will just return the next node.\n    this.logger.debug(\n      `Request #${requestNumber}: No healthy nodes were found. Returning the next node, Node ${candidateNode.index}`,\n    );\n    return candidateNode;\n  }\n\n  nodeDueForHealthcheck(node, requestNumber = 0): boolean {\n    const isDueForHealthcheck =\n      Date.now() - node.lastAccessTimestamp >\n      this.healthcheckIntervalSeconds * 1000;\n    if (isDueForHealthcheck) {\n      this.logger.debug(\n        `Request #${requestNumber}: Node ${node.index} has exceeded healtcheckIntervalSeconds of ${this.healthcheckIntervalSeconds}. Adding it back into rotation.`,\n      );\n    }\n    return isDueForHealthcheck;\n  }\n\n  initializeMetadataForNodes(): void {\n    if (this.nearestNode != null) {\n      this.nearestNode.index = \"nearestNode\";\n      this.setNodeHealthcheck(this.nearestNode, HEALTHY);\n    }\n\n    this.nodes.forEach((node, i) => {\n      node.index = i;\n      this.setNodeHealthcheck(node, HEALTHY);\n    });\n  }\n\n  setNodeHealthcheck(node, isHealthy): void {\n    node.isHealthy = isHealthy;\n    node.lastAccessTimestamp = Date.now();\n  }\n\n  uriFor(endpoint: string, node): string {\n    if (node.url != null) {\n      return `${node.url}${endpoint}`;\n    }\n    return `${node.protocol}://${node.host}:${node.port}${node.path}${endpoint}`;\n  }\n\n  defaultHeaders(): any {\n    const defaultHeaders = {};\n    if (!this.sendApiKeyAsQueryParam) {\n      defaultHeaders[APIKEYHEADERNAME] = this.apiKey;\n    }\n    defaultHeaders[\"Content-Type\"] = \"application/json\";\n    return defaultHeaders;\n  }\n\n  async timer(seconds): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n  }\n\n  customErrorForResponse(\n    response: AxiosResponse,\n    messageFromServer: string,\n  ): TypesenseError {\n    let errorMessage = `Request failed with HTTP code ${response.status}`;\n    if (\n      typeof messageFromServer === \"string\" &&\n      messageFromServer.trim() !== \"\"\n    ) {\n      errorMessage += ` | Server said: ${messageFromServer}`;\n    }\n\n    let error = new TypesenseError(errorMessage);\n\n    if (response.status === 400) {\n      error = new RequestMalformed(errorMessage);\n    } else if (response.status === 401) {\n      error = new RequestUnauthorized(errorMessage);\n    } else if (response.status === 404) {\n      error = new ObjectNotFound(errorMessage);\n    } else if (response.status === 409) {\n      error = new ObjectAlreadyExists(errorMessage);\n    } else if (response.status === 422) {\n      error = new ObjectUnprocessable(errorMessage);\n    } else if (response.status >= 500 && response.status <= 599) {\n      error = new ServerError(errorMessage);\n    } else {\n      error = new HTTPError(errorMessage);\n    }\n\n    error.httpStatus = response.status;\n\n    return error;\n  }\n}\n","import type { ReadStream } from \"fs\";\nimport ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport { ImportError } from \"./Errors\";\nimport { SearchOnlyDocuments } from \"./SearchOnlyDocuments\";\n\n// Todo: use generic to extract filter_by values\nexport interface DeleteQuery {\n  filter_by?: string;\n  batch_size?: number;\n  ignore_not_found?: boolean;\n}\n\nexport interface DeleteResponse {\n  num_deleted: number;\n}\n\ninterface ImportResponseSuccess {\n  success: true;\n}\n\nexport interface ImportResponseFail {\n  success: false;\n  error: string;\n  document: DocumentSchema;\n  code: number;\n}\n\nexport type ImportResponse = ImportResponseSuccess | ImportResponseFail;\n\nexport type DocumentSchema = Record<string, any>;\n\nexport interface SearchParamsWithPreset extends Partial<SearchParams> {\n  preset: string;\n}\n\ntype OperationMode = \"off\" | \"always\" | \"fallback\";\nexport interface SearchParams {\n  // From https://typesense.org/docs/latest/api/documents.html#arguments\n  q?: string;\n  query_by?: string | string[];\n  query_by_weights?: string | number[];\n  prefix?: string | boolean | boolean[]; // default: true\n  filter_by?: string;\n  enable_lazy_filter?: boolean; // default: false\n  sort_by?: string | string[]; // default: text match desc\n  facet_by?: string | string[];\n  max_facet_values?: number;\n  facet_sample_threshold?: number;\n  facet_sample_percent?: number;\n  facet_query?: string;\n  facet_query_num_typos?: number;\n  facet_return_parent?: string;\n  page?: number; // default: 1\n  per_page?: number; // default: 10, max 250\n  group_by?: string | string[];\n  group_limit?: number; // default:\n  group_missing_values?: boolean;\n  include_fields?: string | string[];\n  exclude_fields?: string | string[];\n  highlight_fields?: string | string[]; // default: all queried fields\n  highlight_full_fields?: string | string[]; // default: all fields\n  highlight_affix_num_tokens?: number; // default: 4\n  highlight_start_tag?: string; // default: <mark>\n  highlight_end_tag?: string; // default: </mark>\n  enable_highlight_v1?: boolean;\n  snippet_threshold?: number; // default: 30\n  num_typos?: string | number | number[]; // default: 2\n  min_len_1typo?: number;\n  min_len_2typo?: number;\n  split_join_tokens?: OperationMode;\n  exhaustive_search?: boolean;\n  drop_tokens_threshold?: number; // default: 10\n  typo_tokens_threshold?: number; // default: 100\n  pinned_hits?: string | string[];\n  hidden_hits?: string | string[];\n  limit_hits?: number; // default: no limit\n  pre_segmented_query?: boolean;\n  enable_overrides?: boolean;\n  prioritize_exact_match?: boolean; // default: true\n  prioritize_token_position?: boolean;\n  prioritize_num_matching_fields?: boolean;\n  search_cutoff_ms?: number;\n  use_cache?: boolean;\n  max_candidates?: number;\n  infix?: OperationMode | OperationMode[];\n  preset?: string;\n  text_match_type?: \"max_score\" | \"max_weight\";\n  vector_query?: string;\n  \"x-typesense-api-key\"?: string;\n  \"x-typesense-user-id\"?: string;\n  offset?: number;\n  limit?: number;\n  stopwords?: string;\n  conversation?: boolean;\n  conversation_model_id?: string;\n  conversation_id?: string;\n  voice_query?: string;\n}\n\ntype SearchResponseHighlightObject = {\n  matched_tokens?: string[];\n  snippet?: string;\n  value?: string;\n};\n\nexport type SearchResponseHighlight<T> = T extends string | number\n  ? SearchResponseHighlightObject\n  : {\n      [TAttribute in keyof T]?: SearchResponseHighlight<T[TAttribute]>;\n    };\n\nexport interface SearchResponseHit<T extends DocumentSchema> {\n  curated?: true;\n  highlights?: [\n    {\n      field: keyof T;\n      snippet?: string;\n      value?: string;\n      snippets?: string[];\n      indices?: number[];\n      matched_tokens: string[][] | string[];\n    },\n  ];\n  highlight: SearchResponseHighlight<T>;\n  document: T;\n  text_match: number;\n  text_match_info?: {\n    best_field_score: string; // To prevent scores from being truncated by JSON spec\n    best_field_weight: number;\n    fields_matched: number;\n    score: string; // To prevent scores from being truncated by JSON spec\n    tokens_matched: number;\n  };\n}\n\nexport interface SearchResponseFacetCountSchema<T extends DocumentSchema> {\n  counts: {\n    count: number;\n    highlighted: string;\n    value: string;\n  }[];\n  field_name: keyof T;\n  stats: {\n    avg?: number;\n    max?: number;\n    min?: number;\n    sum?: number;\n  };\n}\n\nexport interface SearchResponseRequestParams {\n  collection_name?: string;\n  q?: string;\n  page?: number;\n  per_page?: number;\n  first_q?: string;\n  voice_query?: {\n    transcribed_query?: string;\n  };\n}\n\n// Todo: we could infer whether this is a grouped response by adding the search params as a generic\nexport interface SearchResponse<T extends DocumentSchema> {\n  facet_counts?: SearchResponseFacetCountSchema<T>[];\n  found: number;\n  found_docs?: number;\n  out_of: number;\n  page: number;\n  request_params: SearchResponseRequestParams;\n  search_time_ms: number;\n  search_cutoff?: boolean;\n  hits?: SearchResponseHit<T>[];\n  grouped_hits?: {\n    group_key: string[];\n    hits: SearchResponseHit<T>[];\n    found?: number;\n  }[];\n  conversation?: {\n    answer: string;\n    conversation_history: {\n      conversation: object[];\n      id: string;\n      last_updated: number;\n      ttl: number;\n    };\n    conversation_id: string;\n    query: string;\n  };\n  error?: string;\n  code?: number;\n}\n\nexport interface DocumentWriteParameters {\n  dirty_values?: \"coerce_or_reject\" | \"coerce_or_drop\" | \"drop\" | \"reject\";\n  action?: \"create\" | \"update\" | \"upsert\" | \"emplace\";\n}\n\nexport interface UpdateByFilterParameters {\n  filter_by?: string;\n}\n\nexport interface UpdateByFilterResponse {\n  num_updated: number;\n}\n\nexport interface DocumentImportParameters extends DocumentWriteParameters {\n  batch_size?: number;\n  return_doc?: boolean;\n  return_id?: boolean;\n}\n\nexport interface DocumentsExportParameters {\n  filter_by?: string;\n  include_fields?: string;\n  exclude_fields?: string;\n}\n\nexport interface SearchableDocuments<T extends DocumentSchema> {\n  search(\n    searchParameters: SearchParams | SearchParamsWithPreset,\n    options: SearchOptions,\n  ): Promise<SearchResponse<T>>;\n  clearCache(): void;\n}\n\nexport interface WriteableDocuments<T> {\n  create(document: T, options: DocumentWriteParameters): Promise<T>;\n  upsert(document: T, options: DocumentWriteParameters): Promise<T>;\n  update(document: T, options: DocumentWriteParameters): Promise<T>;\n  delete(query: DeleteQuery): Promise<DeleteResponse>;\n  import(\n    documents: T[] | string,\n    options: DocumentWriteParameters,\n  ): Promise<string | ImportResponse[]>;\n  export(options: DocumentsExportParameters): Promise<string>;\n}\n\nexport interface SearchOptions {\n  cacheSearchResultsForSeconds?: number;\n  abortSignal?: AbortSignal | null;\n}\n\nconst isNodeJSEnvironment =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nexport default class Documents<T extends DocumentSchema = object>\n  extends SearchOnlyDocuments<T>\n  implements WriteableDocuments<T>\n{\n  constructor(\n    collectionName: string,\n    apiCall: ApiCall,\n    configuration: Configuration,\n  ) {\n    super(collectionName, apiCall, configuration);\n  }\n\n  async create(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(this.endpointPath(), document, options);\n  }\n\n  async upsert(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(\n      this.endpointPath(),\n      document,\n      Object.assign({}, options, { action: \"upsert\" }),\n    );\n  }\n\n  async update(\n    document: T,\n    options: UpdateByFilterParameters,\n  ): Promise<UpdateByFilterResponse>;\n  async update(document: T, options: DocumentWriteParameters): Promise<T>;\n  async update(\n    document: T,\n    options: DocumentWriteParameters | UpdateByFilterParameters = {},\n  ): Promise<UpdateByFilterResponse | T> {\n    if (!document) throw new Error(\"No document provided\");\n\n    if (options[\"filter_by\"] != null) {\n      return this.apiCall.patch<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options),\n      );\n    } else {\n      return this.apiCall.post<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options, { action: \"update\" }),\n      );\n    }\n  }\n\n  async delete(\n    query: DeleteQuery = {} as DeleteQuery,\n  ): Promise<DeleteResponse> {\n    return this.apiCall.delete<DeleteResponse>(this.endpointPath(), query);\n  }\n\n  async createMany(documents: T[], options: DocumentImportParameters = {}) {\n    this.configuration.logger.warn(\n      \"createMany is deprecated and will be removed in a future version. Use import instead, which now takes both an array of documents or a JSONL string of documents\",\n    );\n    return this.import(documents, options);\n  }\n\n  /**\n   * Import a set of documents in a batch.\n   * @param {string|Array} documents - Can be a JSONL string of documents or an array of document objects.\n   * @param options\n   * @return {string|Array} Returns a JSONL string if the input was a JSONL string, otherwise it returns an array of results.\n   */\n  async import(\n    documents: string,\n    options?: DocumentImportParameters,\n  ): Promise<string>;\n  async import(\n    documents: T[],\n    options?: DocumentImportParameters,\n  ): Promise<ImportResponse[]>;\n  async import(\n    documents: T[] | string,\n    options: DocumentImportParameters = {},\n  ): Promise<string | ImportResponse[]> {\n    let documentsInJSONLFormat;\n    if (Array.isArray(documents)) {\n      try {\n        documentsInJSONLFormat = documents\n          .map((document) => JSON.stringify(document))\n          .join(\"\\n\");\n      } catch (error: any) {\n        // if rangeerror, throw custom error message\n        if (\n          error instanceof RangeError &&\n          error.message.includes(\"Too many properties to enumerate\")\n        ) {\n          throw new Error(`${error}\n          It looks like you have reached a Node.js limit that restricts the number of keys in an Object: https://stackoverflow.com/questions/9282869/are-there-limits-to-the-number-of-properties-in-a-javascript-object\n\n          Please try reducing the number of keys in your document, or using CURL to import your data.\n          `);\n        }\n\n        // else, throw the non-range error anyways\n        throw new Error(error);\n      }\n    } else {\n      documentsInJSONLFormat = documents;\n    }\n\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: documentsInJSONLFormat,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    if (Array.isArray(documents)) {\n      const resultsInJSONFormat = resultsInJSONLFormat\n        .split(\"\\n\")\n        .map((r) => JSON.parse(r)) as ImportResponse[];\n      const failedItems = resultsInJSONFormat.filter(\n        (r) => r.success === false,\n      );\n      if (failedItems.length > 0) {\n        throw new ImportError(\n          `${\n            resultsInJSONFormat.length - failedItems.length\n          } documents imported successfully, ${\n            failedItems.length\n          } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n          resultsInJSONFormat,\n        );\n      } else {\n        return resultsInJSONFormat;\n      }\n    } else {\n      return resultsInJSONLFormat as string;\n    }\n  }\n  /**\n   * Imports documents from a NodeJS readable stream of JSONL.\n   */\n  async importStream(\n    readableStream: ReadStream,\n    options: DocumentImportParameters = {},\n  ): Promise<ImportResponse[]> {\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: readableStream,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    const resultsInJSONFormat = resultsInJSONLFormat\n      .split(\"\\n\")\n      .map((r) => JSON.parse(r)) as ImportResponse[];\n    const failedItems = resultsInJSONFormat.filter((r) => r.success === false);\n    if (failedItems.length > 0) {\n      throw new ImportError(\n        `${\n          resultsInJSONFormat.length - failedItems.length\n        } documents imported successfully, ${\n          failedItems.length\n        } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n        resultsInJSONFormat,\n      );\n    } else {\n      return resultsInJSONFormat;\n    }\n  }\n\n  /**\n   * Returns a JSONL string for all the documents in this collection\n   */\n  async export(options: DocumentsExportParameters = {}): Promise<string> {\n    return this.apiCall.get<string>(this.endpointPath(\"export\"), options);\n  }\n\n  /**\n   * Returns a NodeJS readable stream of JSONL for all the documents in this collection.\n   */\n  async exportStream(\n    options: DocumentsExportParameters = {},\n  ): Promise<ReadStream> {\n    return this.apiCall.get<ReadStream>(this.endpointPath(\"export\"), options, {\n      responseType: \"stream\",\n    });\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport RequestWithCache from \"./RequestWithCache\";\nimport {\n  DocumentSchema,\n  SearchParams,\n  SearchParamsWithPreset,\n  SearchResponse,\n} from \"./Documents\";\n\nconst RESOURCEPATH = \"/multi_search\";\n\nexport interface MultiSearchRequestSchema extends SearchParams {\n  collection?: string;\n  \"x-typesense-api-key\"?: string;\n}\n\nexport interface MultiSearchRequestWithPresetSchema\n  extends SearchParamsWithPreset {\n  collection?: string;\n  \"x-typesense-api-key\"?: string;\n}\n\nexport interface MultiSearchRequestsSchema {\n  searches: (MultiSearchRequestSchema | MultiSearchRequestWithPresetSchema)[];\n}\n\nexport interface MultiSearchResponse<T extends DocumentSchema[] = []> {\n  results: { [Index in keyof T]: SearchResponse<T[Index]> } & {\n    length: T[\"length\"];\n  };\n}\n\nexport default class MultiSearch {\n  private requestWithCache: RequestWithCache;\n\n  constructor(\n    private apiCall: ApiCall,\n    private configuration: Configuration,\n    private useTextContentType: boolean = false\n  ) {\n    this.requestWithCache = new RequestWithCache();\n  }\n\n  clearCache() {\n    this.requestWithCache.clearCache();\n  }\n\n  async perform<T extends DocumentSchema[] = []>(\n    searchRequests: MultiSearchRequestsSchema,\n    commonParams: Partial<MultiSearchRequestSchema> = {},\n    {\n      cacheSearchResultsForSeconds = this.configuration\n        .cacheSearchResultsForSeconds,\n    }: { cacheSearchResultsForSeconds?: number } = {}\n  ): Promise<MultiSearchResponse<T>> {\n    const additionalHeaders = {};\n    if (this.useTextContentType) {\n      additionalHeaders[\"content-type\"] = \"text/plain\";\n    }\n\n    const additionalQueryParams = {};\n    if (this.configuration.useServerSideSearchCache === true) {\n      additionalQueryParams[\"use_cache\"] = true;\n    }\n    const queryParams = Object.assign({}, commonParams, additionalQueryParams);\n\n    return this.requestWithCache.perform(\n      this.apiCall,\n      this.apiCall.post,\n      [RESOURCEPATH, searchRequests, queryParams, additionalHeaders],\n      { cacheResponseForSeconds: cacheSearchResultsForSeconds }\n    ) as Promise<MultiSearchResponse<T>>;\n  }\n}\n"]}