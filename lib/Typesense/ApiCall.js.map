{"version":3,"sources":["Typesense/ApiCall.js"],"names":["APIKEYHEADERNAME","HEALTHY","UNHEALTHY","ApiCall","configuration","_configuration","_apiKey","apiKey","_nodes","JSON","parse","stringify","nodes","_nearestNode","nearestNode","_connectionTimeoutSeconds","connectionTimeoutSeconds","_healthcheckIntervalSeconds","healthcheckIntervalSeconds","_numRetriesPerRequest","numRetries","_retryIntervalSeconds","retryIntervalSeconds","_logger","logger","_initializeMetadataForNodes","_currentNodeIndex","endpoint","parameters","performRequest","undefined","requestType","queryParameters","bodyParameters","additionalHeaders","validate","requestNumber","Date","now","debug","toUpperCase","numTries","node","_getNextNode","index","requestOptions","method","url","_uriFor","headers","Object","assign","_defaultHeaders","params","data","timeout","maxContentLength","Infinity","maxBodyLength","validateStatus","status","transformResponse","transformedData","startsWith","response","_setNodeHealthcheck","Promise","resolve","reject","Error","request","path","message","lastException","warn","code","_timer","isHealthy","_nodeDueForHealthcheck","map","join","candidateNode","i","length","isDueForHealthcheck","lastAccessTimestamp","forEach","protocol","host","port","defaultHeaders","seconds","setTimeout"],"mappings":"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","sourcesContent":["'use strict'\nimport axios from 'axios'\n\nconst APIKEYHEADERNAME = 'X-TYPESENSE-API-KEY'\nconst HEALTHY = true\nconst UNHEALTHY = false\n\nexport default class ApiCall {\n  constructor (configuration) {\n    this._configuration = configuration\n\n    this._apiKey = this._configuration.apiKey\n    this._nodes = JSON.parse(JSON.stringify(this._configuration.nodes)) // Make a copy, since we'll be adding additional metadata to the nodes\n    this._nearestNode = JSON.parse(JSON.stringify(this._configuration.nearestNode))\n    this._connectionTimeoutSeconds = this._configuration.connectionTimeoutSeconds\n    this._healthcheckIntervalSeconds = this._configuration.healthcheckIntervalSeconds\n    this._numRetriesPerRequest = this._configuration.numRetries\n    this._retryIntervalSeconds = this._configuration.retryIntervalSeconds\n\n    this._logger = this._configuration.logger\n\n    this._initializeMetadataForNodes()\n    this._currentNodeIndex = -1\n  }\n\n  get (endpoint, parameters = {}) {\n    return this.performRequest('get', endpoint, parameters)\n  }\n\n  delete (endpoint, parameters = {}) {\n    return this.performRequest('delete', endpoint, parameters)\n  }\n\n  post (endpoint, parameters = {}) {\n    return this.performRequest('post', endpoint, undefined, parameters)\n  }\n\n  put (endpoint, parameters = {}) {\n    return this.performRequest('put', endpoint, undefined, parameters)\n  }\n\n  async performRequest (requestType, endpoint, queryParameters = {}, bodyParameters = {}, additionalHeaders = {}) {\n    this\n      ._configuration\n      .validate()\n\n    const requestNumber = Date.now()\n    let lastException\n    this._logger.debug(`Request #${requestNumber}: Performing ${requestType.toUpperCase()} request: ${endpoint}`)\n    for (let numTries = 1; numTries <= this._numRetriesPerRequest + 1; numTries++) {\n      let node = this._getNextNode(requestNumber)\n      this._logger.debug(`Request #${requestNumber}: Attempting ${requestType.toUpperCase()} request Try #${numTries} to Node ${node.index}`)\n      try {\n        const requestOptions = {\n          method: requestType,\n          url: this._uriFor(endpoint, node),\n          headers: Object.assign({}, this._defaultHeaders(), additionalHeaders),\n          params: queryParameters,\n          data: bodyParameters,\n          timeout: this._connectionTimeoutSeconds * 1000,\n          maxContentLength: Infinity,\n          maxBodyLength: Infinity,\n          validateStatus: (status) => {\n            /* Override default validateStatus, which only considers 2xx a success.\n                In our case, anything below 500 should be considered a \"success\" and not retried.\n                We will handle anything not 2xx, but below 500 as a custom exception below.\n             */\n            return status > 0 && status < 500\n          },\n          transformResponse: [(data, headers) => {\n            let transformedData = data\n            if (headers !== undefined && typeof data === 'string' && headers['content-type'].startsWith('application/json')) {\n              transformedData = JSON.parse(data)\n            }\n            return transformedData\n          }]\n        }\n\n        let response = await axios(requestOptions)\n        this._setNodeHealthcheck(node, HEALTHY)\n\n        this._logger.debug(`Request #${requestNumber}: Request to Node ${node.index} was successfully made. Response Code was ${response.status}.`)\n\n        // If response is 2xx return a resolved promise, else reject\n        if (response.status >= 200 && response.status < 300) {\n          return Promise.resolve(response.data)\n        } else {\n          return Promise.reject(new Error(`${response.request.path} - ${response.data.message}`))\n        }\n      } catch (error) {\n        // This block handles HTTPStatus < 0, HTTPStatus > 500 and network layer issues like connection timeouts\n        this._setNodeHealthcheck(node, UNHEALTHY)\n        lastException = error\n        this._logger.warn(`Request #${requestNumber}: Request to Node ${node.index} failed due to \"${error.code} ${error.message}${error.response == null ? '' : ' - ' + JSON.stringify(error.response.data)}\"`)\n        // this._logger.debug(error.stack)\n        this._logger.warn(`Request #${requestNumber}: Sleeping for ${this._retryIntervalSeconds}s and then retrying request...`)\n        await this._timer(this._retryIntervalSeconds)\n      }\n    }\n    this._logger.debug(`Request #${requestNumber}: No retries left. Raising last error`)\n    return Promise.reject(lastException)\n  }\n\n  // Attempts to find the next healthy node, looping through the list of nodes once.\n  //   But if no healthy nodes are found, it will just return the next node, even if it's unhealthy\n  //     so we can try the request for good measure, in case that node has become healthy since\n  _getNextNode (requestNumber = 0) {\n    // Check if nearestNode is set and is healthy, if so return it\n    if (this._nearestNode != null) {\n      this._logger.debug(`Request #${requestNumber}: Nodes Health: Node ${this._nearestNode.index} is ${this._nearestNode.isHealthy === true ? 'Healthy' : 'Unhealthy'}`)\n      if (this._nearestNode.isHealthy === true || this._nodeDueForHealthcheck(this._nearestNode, requestNumber)) {\n        this._logger.debug(`Request #${requestNumber}: Updated current node to Node ${this._nearestNode.index}`)\n        return this._nearestNode\n      }\n      this._logger.debug(`Request #${requestNumber}: Falling back to individual nodes`)\n    }\n\n    // Fallback to nodes as usual\n    this._logger.debug(`Request #${requestNumber}: Nodes Health: ${this._nodes.map(node => `Node ${node.index} is ${node.isHealthy === true ? 'Healthy' : 'Unhealthy'}`).join(' || ')}`)\n    let candidateNode\n    for (let i = 0; i <= this._nodes.length; i++) {\n      this._currentNodeIndex = (this._currentNodeIndex + 1) % this._nodes.length\n      candidateNode = this._nodes[this._currentNodeIndex]\n      if (candidateNode.isHealthy === true || this._nodeDueForHealthcheck(candidateNode, requestNumber)) {\n        this._logger.debug(`Request #${requestNumber}: Updated current node to Node ${candidateNode.index}`)\n        return candidateNode\n      }\n    }\n\n    // None of the nodes are marked healthy, but some of them could have become healthy since last health check.\n    //  So we will just return the next node.\n    this._logger.debug(`Request #${requestNumber}: No healthy nodes were found. Returning the next node, Node ${candidateNode.index}`)\n    return candidateNode\n  }\n\n  _nodeDueForHealthcheck (node, requestNumber = 0) {\n    const isDueForHealthcheck = Date.now() - node.lastAccessTimestamp > (this._healthcheckIntervalSeconds * 1000)\n    if (isDueForHealthcheck) {\n      this._logger.debug(`Request #${requestNumber}: Node ${node.index} has exceeded healtcheckIntervalSeconds of ${this._healthcheckIntervalSeconds}. Adding it back into rotation.`)\n    }\n    return isDueForHealthcheck\n  }\n\n  _initializeMetadataForNodes () {\n    if (this._nearestNode != null) {\n      this._nearestNode.index = 'nearestNode'\n      this._setNodeHealthcheck(this._nearestNode, HEALTHY)\n    }\n\n    this._nodes.forEach((node, i) => {\n      node.index = i\n      this._setNodeHealthcheck(node, HEALTHY)\n    })\n  }\n\n  _setNodeHealthcheck (node, isHealthy) {\n    node.isHealthy = isHealthy\n    node.lastAccessTimestamp = Date.now()\n  }\n\n  _uriFor (endpoint, node) {\n    return `${node.protocol}://${node.host}:${node.port}${node.path}${endpoint}`\n  }\n\n  _defaultHeaders () {\n    let defaultHeaders = {}\n    defaultHeaders[APIKEYHEADERNAME] = this._apiKey\n    defaultHeaders['Content-Type'] = 'application/json'\n    return defaultHeaders\n  }\n\n  async _timer (seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000))\n  }\n}\n"],"file":"ApiCall.js"}