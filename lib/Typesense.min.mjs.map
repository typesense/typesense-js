{"version":3,"sources":["../src/Typesense/Configuration.ts","../src/Typesense/Errors/index.ts","../src/Typesense/Errors/TypesenseError.ts","../src/Typesense/Errors/HTTPError.ts","../src/Typesense/Errors/MissingConfigurationError.ts","../src/Typesense/Errors/ObjectAlreadyExists.ts","../src/Typesense/Errors/ObjectNotFound.ts","../src/Typesense/Errors/ObjectUnprocessable.ts","../src/Typesense/Errors/RequestMalformed.ts","../src/Typesense/Errors/RequestUnauthorized.ts","../src/Typesense/Errors/ServerError.ts","../src/Typesense/Errors/ImportError.ts","../src/Typesense/ApiCall.ts","../src/Typesense/Collections.ts","../src/Typesense/RequestWithCache.ts","../src/Typesense/SearchOnlyDocuments.ts","../src/Typesense/Documents.ts","../src/Typesense/Overrides.ts","../src/Typesense/Override.ts","../src/Typesense/Synonyms.ts","../src/Typesense/Synonym.ts","../src/Typesense/Document.ts","../src/Typesense/Collection.ts","../src/Typesense/Aliases.ts","../src/Typesense/Alias.ts","../src/Typesense/Keys.ts","../src/Typesense/Key.ts","../src/Typesense/Debug.ts","../src/Typesense/Metrics.ts","../src/Typesense/Stats.ts","../src/Typesense/Health.ts","../src/Typesense/Operations.ts","../src/Typesense/MultiSearch.ts","../src/Typesense/Presets.ts","../src/Typesense/Preset.ts","../src/Typesense/AnalyticsRules.ts","../src/Typesense/AnalyticsRule.ts","../src/Typesense/AnalyticsEvents.ts","../src/Typesense/Analytics.ts","../src/Typesense/Stopwords.ts","../src/Typesense/Stopword.ts","../src/Typesense/ConversationModels.ts","../src/Typesense/ConversationModel.ts","../src/Typesense/Conversations.ts","../src/Typesense/Conversation.ts","../src/Typesense/Client.ts","../src/Typesense/SearchOnlyCollection.ts","../src/Typesense/SearchClient.ts","../src/Typesense.ts"],"sourcesContent":["import * as logger from \"loglevel\";\nimport { Logger, LogLevelDesc } from \"loglevel\";\nimport { MissingConfigurationError } from \"./Errors\";\nimport type { Agent as HTTPAgent } from \"http\";\nimport type { Agent as HTTPSAgent } from \"https\";\n\nexport interface NodeConfiguration {\n  host: string;\n  port: number;\n  protocol: string;\n  path?: string;\n  url?: string;\n}\n\nexport interface NodeConfigurationWithHostname {\n  host: string;\n  port: number;\n  protocol: string;\n  path?: string;\n}\n\nexport interface NodeConfigurationWithUrl {\n  url: string;\n}\n\nexport interface ConfigurationOptions {\n  apiKey: string;\n  nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  randomizeNodes?: boolean;\n  /**\n   * @deprecated\n   * masterNode is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  masterNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  /**\n   * @deprecated\n   * readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  readReplicaNodes?:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  connectionTimeoutSeconds?: number;\n  timeoutSeconds?: number;\n  healthcheckIntervalSeconds?: number;\n  numRetries?: number;\n  retryIntervalSeconds?: number;\n  sendApiKeyAsQueryParam?: boolean | undefined;\n  useServerSideSearchCache?: boolean;\n  cacheSearchResultsForSeconds?: number;\n  additionalHeaders?: Record<string, string>;\n\n  logLevel?: LogLevelDesc;\n  logger?: Logger;\n\n  /**\n   * Set a custom HTTP Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPAgent } = require(\"http\");\n   *      ...\n   *      httpAgent: new HTTPAgent({ keepAlive: true }),\n   * @type {HTTPAgent}\n   */\n  httpAgent?: HTTPAgent;\n\n  /**\n   * Set a custom HTTPS Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPSAgent } = require(\"https\");\n   *      ...\n   *      httpsAgent: new HTTPSAgent({ keepAlive: true }),\n   * @type {HTTPSAgent}\n   */\n  httpsAgent?: HTTPSAgent;\n\n  /**\n   * Set a custom paramsSerializer\n   *\n   * See axios documentation for more information on how to use this parameter: https://axios-http.com/docs/req_config\n   *  This is helpful for handling React Native issues like this: https://github.com/axios/axios/issues/6102#issuecomment-2085301397\n   * @type {any}\n   */\n  paramsSerializer?: any;\n}\n\nexport default class Configuration {\n  readonly nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[];\n  readonly nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl;\n  readonly connectionTimeoutSeconds: number;\n  readonly healthcheckIntervalSeconds: number;\n  readonly numRetries: number;\n  readonly retryIntervalSeconds: number;\n  readonly apiKey: string;\n  readonly sendApiKeyAsQueryParam?: boolean;\n  readonly cacheSearchResultsForSeconds: number;\n  readonly useServerSideSearchCache: boolean;\n  readonly logger: Logger;\n  readonly logLevel: LogLevelDesc;\n  readonly additionalHeaders?: Record<string, string>;\n  readonly httpAgent?: HTTPAgent;\n  readonly httpsAgent?: HTTPSAgent;\n  readonly paramsSerializer?: any;\n\n  constructor(options: ConfigurationOptions) {\n    this.nodes = options.nodes || [];\n    this.nodes = this.nodes\n      .map((node) => this.setDefaultPathInNode(node))\n      .map((node) => this.setDefaultPortInNode(node))\n      .map((node) => ({ ...node })) as NodeConfiguration[]; // Make a deep copy\n\n    if (options.randomizeNodes == null) {\n      options.randomizeNodes = true;\n    }\n\n    if (options.randomizeNodes === true) {\n      this.shuffleArray(this.nodes);\n    }\n\n    this.nearestNode = options.nearestNode;\n    this.nearestNode = this.setDefaultPathInNode(this.nearestNode);\n    this.nearestNode = this.setDefaultPortInNode(this.nearestNode);\n\n    this.connectionTimeoutSeconds =\n      options.connectionTimeoutSeconds || options.timeoutSeconds || 5;\n    this.healthcheckIntervalSeconds = options.healthcheckIntervalSeconds || 60;\n    this.numRetries =\n      options.numRetries ||\n      this.nodes.length + (this.nearestNode == null ? 0 : 1) ||\n      3;\n    this.retryIntervalSeconds = options.retryIntervalSeconds || 0.1;\n\n    this.apiKey = options.apiKey;\n    this.sendApiKeyAsQueryParam = options.sendApiKeyAsQueryParam; // We will set a default for this in Client and SearchClient\n\n    this.cacheSearchResultsForSeconds =\n      options.cacheSearchResultsForSeconds || 0; // Disable client-side cache by default\n    this.useServerSideSearchCache = options.useServerSideSearchCache || false;\n\n    this.logger = options.logger || logger;\n    this.logLevel = options.logLevel || \"warn\";\n    this.logger.setLevel(this.logLevel);\n\n    this.additionalHeaders = options.additionalHeaders;\n\n    this.httpAgent = options.httpAgent;\n    this.httpsAgent = options.httpsAgent;\n\n    this.paramsSerializer = options.paramsSerializer;\n\n    this.showDeprecationWarnings(options);\n    this.validate();\n  }\n\n  validate(): boolean {\n    if (this.nodes == null || this.nodes.length === 0 || this.validateNodes()) {\n      throw new MissingConfigurationError(\n        \"Ensure that nodes[].protocol, nodes[].host and nodes[].port are set\",\n      );\n    }\n\n    if (\n      this.nearestNode != null &&\n      this.isNodeMissingAnyParameters(this.nearestNode)\n    ) {\n      throw new MissingConfigurationError(\n        \"Ensure that nearestNodes.protocol, nearestNodes.host and nearestNodes.port are set\",\n      );\n    }\n\n    if (this.apiKey == null) {\n      throw new MissingConfigurationError(\"Ensure that apiKey is set\");\n    }\n\n    return true;\n  }\n\n  private validateNodes(): boolean {\n    return this.nodes.some((node) => {\n      return this.isNodeMissingAnyParameters(node);\n    });\n  }\n\n  private isNodeMissingAnyParameters(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl,\n  ): boolean {\n    return (\n      ![\"protocol\", \"host\", \"port\", \"path\"].every((key) => {\n        return node.hasOwnProperty(key);\n      }) && node[\"url\"] == null\n    );\n  }\n\n  private setDefaultPathInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined,\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (node != null && !node.hasOwnProperty(\"path\")) {\n      node[\"path\"] = \"\";\n    }\n    return node;\n  }\n\n  private setDefaultPortInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined,\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (\n      node != null &&\n      !node.hasOwnProperty(\"port\") &&\n      node.hasOwnProperty(\"protocol\")\n    ) {\n      switch (node[\"protocol\"]) {\n        case \"https\":\n          node[\"port\"] = 443;\n          break;\n        case \"http\":\n          node[\"port\"] = 80;\n          break;\n      }\n    }\n    return node;\n  }\n\n  private showDeprecationWarnings(options: ConfigurationOptions): void {\n    if (options.timeoutSeconds) {\n      this.logger.warn(\n        \"Deprecation warning: timeoutSeconds is now renamed to connectionTimeoutSeconds\",\n      );\n    }\n    if (options.masterNode) {\n      this.logger.warn(\n        \"Deprecation warning: masterNode is now consolidated to nodes, starting with Typesense Server v0.12\",\n      );\n    }\n    if (options.readReplicaNodes) {\n      this.logger.warn(\n        \"Deprecation warning: readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12\",\n      );\n    }\n  }\n\n  private shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n}\n","import HTTPError from \"./HTTPError\";\nimport MissingConfigurationError from \"./MissingConfigurationError\";\nimport ObjectAlreadyExists from \"./ObjectAlreadyExists\";\nimport ObjectNotFound from \"./ObjectNotFound\";\nimport ObjectUnprocessable from \"./ObjectUnprocessable\";\nimport RequestMalformed from \"./RequestMalformed\";\nimport RequestUnauthorized from \"./RequestUnauthorized\";\nimport ServerError from \"./ServerError\";\nimport ImportError from \"./ImportError\";\nimport TypesenseError from \"./TypesenseError\";\n\nexport {\n  HTTPError,\n  MissingConfigurationError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n  TypesenseError,\n  ImportError,\n};\n","export default class TypesenseError extends Error {\n  httpStatus?: number;\n\n  // Source: https://stackoverflow.com/a/58417721/123545\n  constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class HTTPError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class MissingConfigurationError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectAlreadyExists extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectNotFound extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectUnprocessable extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestMalformed extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestUnauthorized extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ServerError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\nimport { ImportResponse } from \"../Documents\";\n\nexport default class ImportError extends TypesenseError {\n  importResults: ImportResponse[];\n  constructor(message: string, importResults: ImportResponse[]) {\n    super(message);\n    this.importResults = importResults;\n  }\n}\n","import axios, { AxiosRequestConfig, AxiosResponse, Method } from \"axios\";\nimport { Logger } from \"loglevel\";\nimport {\n  HTTPError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n} from \"./Errors\";\nimport TypesenseError from \"./Errors/TypesenseError\";\nimport Configuration, { NodeConfiguration } from \"./Configuration\";\nimport { Agent as HTTPAgent } from \"http\";\nimport { Agent as HTTPSAgent } from \"https\";\n\nconst APIKEYHEADERNAME = \"X-TYPESENSE-API-KEY\";\nconst HEALTHY = true;\nconst UNHEALTHY = false;\n\ninterface Node extends NodeConfiguration {\n  isHealthy: boolean;\n  index: string | number;\n}\n\nconst isNodeJSEnvironment =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nexport default class ApiCall {\n  private readonly apiKey: string;\n  private readonly nodes: Node[];\n  private readonly nearestNode: Node;\n  private readonly connectionTimeoutSeconds: number;\n  private readonly healthcheckIntervalSeconds: number;\n  private readonly retryIntervalSeconds: number;\n  private readonly sendApiKeyAsQueryParam?: boolean;\n  private readonly numRetriesPerRequest: number;\n  private readonly additionalUserHeaders?: Record<string, string>;\n\n  private readonly logger: Logger;\n  private currentNodeIndex: number;\n\n  constructor(private configuration: Configuration) {\n    this.apiKey = this.configuration.apiKey;\n    this.nodes =\n      this.configuration.nodes == null\n        ? this.configuration.nodes\n        : JSON.parse(JSON.stringify(this.configuration.nodes)); // Make a copy, since we'll be adding additional metadata to the nodes\n    this.nearestNode =\n      this.configuration.nearestNode == null\n        ? this.configuration.nearestNode\n        : JSON.parse(JSON.stringify(this.configuration.nearestNode));\n    this.connectionTimeoutSeconds = this.configuration.connectionTimeoutSeconds;\n    this.healthcheckIntervalSeconds =\n      this.configuration.healthcheckIntervalSeconds;\n    this.numRetriesPerRequest = this.configuration.numRetries;\n    this.retryIntervalSeconds = this.configuration.retryIntervalSeconds;\n    this.sendApiKeyAsQueryParam = this.configuration.sendApiKeyAsQueryParam;\n    this.additionalUserHeaders = this.configuration.additionalHeaders;\n\n    this.logger = this.configuration.logger;\n\n    this.initializeMetadataForNodes();\n    this.currentNodeIndex = -1;\n  }\n\n  async get<T>(\n    endpoint: string,\n    queryParameters: any = {},\n    {\n      abortSignal = null,\n      responseType = undefined,\n    }: {\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n    } = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"get\", endpoint, {\n      queryParameters,\n      abortSignal,\n      responseType,\n    });\n  }\n\n  async delete<T>(endpoint: string, queryParameters: any = {}): Promise<T> {\n    return this.performRequest<T>(\"delete\", endpoint, { queryParameters });\n  }\n\n  async post<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n    additionalHeaders: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"post\", endpoint, {\n      queryParameters,\n      bodyParameters,\n      additionalHeaders,\n    });\n  }\n\n  async put<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"put\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async patch<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"patch\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async performRequest<T>(\n    requestType: Method,\n    endpoint: string,\n    {\n      queryParameters = null,\n      bodyParameters = null,\n      additionalHeaders = {},\n      abortSignal = null,\n      responseType = undefined,\n      skipConnectionTimeout = false,\n      enableKeepAlive = undefined,\n    }: {\n      queryParameters?: any;\n      bodyParameters?: any;\n      additionalHeaders?: any;\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n      skipConnectionTimeout?: boolean;\n      enableKeepAlive?: boolean | undefined;\n    },\n  ): Promise<T> {\n    this.configuration.validate();\n\n    const requestNumber = Date.now();\n    let lastException;\n    this.logger.debug(\n      `Request #${requestNumber}: Performing ${requestType.toUpperCase()} request: ${endpoint}`,\n    );\n    for (\n      let numTries = 1;\n      numTries <= this.numRetriesPerRequest + 1;\n      numTries++\n    ) {\n      const node = this.getNextNode(requestNumber);\n      this.logger.debug(\n        `Request #${requestNumber}: Attempting ${requestType.toUpperCase()} request Try #${numTries} to Node ${\n          node.index\n        }`,\n      );\n\n      if (abortSignal && abortSignal.aborted) {\n        return Promise.reject(new Error(\"Request aborted by caller.\"));\n      }\n\n      let abortListener;\n\n      try {\n        const requestOptions: AxiosRequestConfig = {\n          method: requestType,\n          url: this.uriFor(endpoint, node),\n          headers: Object.assign(\n            {},\n            this.defaultHeaders(),\n            additionalHeaders,\n            this.additionalUserHeaders,\n          ),\n          maxContentLength: Infinity,\n          maxBodyLength: Infinity,\n          responseType,\n          validateStatus: (status) => {\n            /* Override default validateStatus, which only considers 2xx a success.\n                In our case, if the server returns any HTTP code, we will handle it below.\n                We do this to be able to raise custom errors based on response code.\n             */\n            return status > 0;\n          },\n          transformResponse: [\n            (data, headers) => {\n              let transformedData = data;\n              if (\n                headers !== undefined &&\n                typeof data === \"string\" &&\n                headers[\"content-type\"] &&\n                headers[\"content-type\"].startsWith(\"application/json\")\n              ) {\n                transformedData = JSON.parse(data);\n              }\n              return transformedData;\n            },\n          ],\n        };\n\n        if (skipConnectionTimeout !== true) {\n          requestOptions.timeout = this.connectionTimeoutSeconds * 1000;\n        }\n\n        if (queryParameters && Object.keys(queryParameters).length !== 0) {\n          requestOptions.params = queryParameters;\n        }\n\n        if (this.sendApiKeyAsQueryParam) {\n          requestOptions.params = requestOptions.params || {};\n          requestOptions.params[\"x-typesense-api-key\"] = this.apiKey;\n        }\n\n        if (this.configuration.httpAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpAgent`,\n          );\n          requestOptions.httpAgent = this.configuration.httpAgent;\n        } else if (enableKeepAlive === true) {\n          if (!isNodeJSEnvironment) {\n            this.logger.warn(\n              `Request #${requestNumber}: Cannot use custom httpAgent in a browser environment to enable keepAlive`,\n            );\n          } else {\n            this.logger.debug(`Request #${requestNumber}: Enabling KeepAlive`);\n            requestOptions.httpAgent = new HTTPAgent({ keepAlive: true });\n          }\n        }\n\n        if (this.configuration.httpsAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpsAgent`,\n          );\n          requestOptions.httpsAgent = this.configuration.httpsAgent;\n        } else if (enableKeepAlive === true) {\n          if (!isNodeJSEnvironment) {\n            this.logger.warn(\n              `Request #${requestNumber}: Cannot use custom httpAgent in a browser environment to enable keepAlive`,\n            );\n          } else {\n            this.logger.debug(`Request #${requestNumber}: Enabling keepAlive`);\n            requestOptions.httpsAgent = new HTTPSAgent({ keepAlive: true });\n          }\n        }\n\n        if (this.configuration.paramsSerializer) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom paramsSerializer`,\n          );\n          requestOptions.paramsSerializer = this.configuration.paramsSerializer;\n        }\n\n        if (\n          bodyParameters &&\n          ((typeof bodyParameters === \"string\" &&\n            bodyParameters.length !== 0) ||\n            (typeof bodyParameters === \"object\" &&\n              Object.keys(bodyParameters).length !== 0))\n        ) {\n          requestOptions.data = bodyParameters;\n        }\n\n        // Translate from user-provided AbortController to the Axios request cancel mechanism.\n        if (abortSignal) {\n          const cancelToken = axios.CancelToken;\n          const source = cancelToken.source();\n          abortListener = () => source.cancel();\n          abortSignal.addEventListener(\"abort\", abortListener);\n          requestOptions.cancelToken = source.token;\n        }\n\n        const response = await axios(requestOptions);\n        if (response.status >= 1 && response.status <= 499) {\n          // Treat any status code > 0 and < 500 to be an indication that node is healthy\n          // We exclude 0 since some clients return 0 when request fails\n          this.setNodeHealthcheck(node, HEALTHY);\n        }\n        this.logger.debug(\n          `Request #${requestNumber}: Request to Node ${node.index} was made. Response Code was ${response.status}.`,\n        );\n\n        if (response.status >= 200 && response.status < 300) {\n          // If response is 2xx return a resolved promise\n          return Promise.resolve(response.data);\n        } else if (response.status < 500) {\n          // Next, if response is anything but 5xx, don't retry, return a custom error\n          return Promise.reject(\n            this.customErrorForResponse(response, response.data?.message),\n          );\n        } else {\n          // Retry all other HTTP errors (HTTPStatus > 500)\n          // This will get caught by the catch block below\n          throw this.customErrorForResponse(response, response.data?.message);\n        }\n      } catch (error: any) {\n        // This block handles retries for HTTPStatus > 500 and network layer issues like connection timeouts\n        this.setNodeHealthcheck(node, UNHEALTHY);\n        lastException = error;\n        this.logger.warn(\n          `Request #${requestNumber}: Request to Node ${\n            node.index\n          } failed due to \"${error.code} ${error.message}${\n            error.response == null\n              ? \"\"\n              : \" - \" + JSON.stringify(error.response?.data)\n          }\"`,\n        );\n        // this.logger.debug(error.stack)\n        this.logger.warn(\n          `Request #${requestNumber}: Sleeping for ${this.retryIntervalSeconds}s and then retrying request...`,\n        );\n        await this.timer(this.retryIntervalSeconds);\n      } finally {\n        if (abortSignal && abortListener) {\n          abortSignal.removeEventListener(\"abort\", abortListener);\n        }\n      }\n    }\n    this.logger.debug(\n      `Request #${requestNumber}: No retries left. Raising last error`,\n    );\n    return Promise.reject(lastException);\n  }\n\n  // Attempts to find the next healthy node, looping through the list of nodes once.\n  //   But if no healthy nodes are found, it will just return the next node, even if it's unhealthy\n  //     so we can try the request for good measure, in case that node has become healthy since\n  getNextNode(requestNumber = 0): Node {\n    // Check if nearestNode is set and is healthy, if so return it\n    if (this.nearestNode != null) {\n      this.logger.debug(\n        `Request #${requestNumber}: Nodes Health: Node ${\n          this.nearestNode.index\n        } is ${this.nearestNode.isHealthy === true ? \"Healthy\" : \"Unhealthy\"}`,\n      );\n      if (\n        this.nearestNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(this.nearestNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${this.nearestNode.index}`,\n        );\n        return this.nearestNode;\n      }\n      this.logger.debug(\n        `Request #${requestNumber}: Falling back to individual nodes`,\n      );\n    }\n\n    // Fallback to nodes as usual\n    this.logger.debug(\n      `Request #${requestNumber}: Nodes Health: ${this.nodes\n        .map(\n          (node) =>\n            `Node ${node.index} is ${\n              node.isHealthy === true ? \"Healthy\" : \"Unhealthy\"\n            }`,\n        )\n        .join(\" || \")}`,\n    );\n    let candidateNode: Node = this.nodes[0];\n    for (let i = 0; i <= this.nodes.length; i++) {\n      this.currentNodeIndex = (this.currentNodeIndex + 1) % this.nodes.length;\n      candidateNode = this.nodes[this.currentNodeIndex];\n      if (\n        candidateNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(candidateNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${candidateNode.index}`,\n        );\n        return candidateNode;\n      }\n    }\n\n    // None of the nodes are marked healthy, but some of them could have become healthy since last health check.\n    //  So we will just return the next node.\n    this.logger.debug(\n      `Request #${requestNumber}: No healthy nodes were found. Returning the next node, Node ${candidateNode.index}`,\n    );\n    return candidateNode;\n  }\n\n  nodeDueForHealthcheck(node, requestNumber = 0): boolean {\n    const isDueForHealthcheck =\n      Date.now() - node.lastAccessTimestamp >\n      this.healthcheckIntervalSeconds * 1000;\n    if (isDueForHealthcheck) {\n      this.logger.debug(\n        `Request #${requestNumber}: Node ${node.index} has exceeded healtcheckIntervalSeconds of ${this.healthcheckIntervalSeconds}. Adding it back into rotation.`,\n      );\n    }\n    return isDueForHealthcheck;\n  }\n\n  initializeMetadataForNodes(): void {\n    if (this.nearestNode != null) {\n      this.nearestNode.index = \"nearestNode\";\n      this.setNodeHealthcheck(this.nearestNode, HEALTHY);\n    }\n\n    this.nodes.forEach((node, i) => {\n      node.index = i;\n      this.setNodeHealthcheck(node, HEALTHY);\n    });\n  }\n\n  setNodeHealthcheck(node, isHealthy): void {\n    node.isHealthy = isHealthy;\n    node.lastAccessTimestamp = Date.now();\n  }\n\n  uriFor(endpoint: string, node): string {\n    if (node.url != null) {\n      return `${node.url}${endpoint}`;\n    }\n    return `${node.protocol}://${node.host}:${node.port}${node.path}${endpoint}`;\n  }\n\n  defaultHeaders(): any {\n    const defaultHeaders = {};\n    if (!this.sendApiKeyAsQueryParam) {\n      defaultHeaders[APIKEYHEADERNAME] = this.apiKey;\n    }\n    defaultHeaders[\"Content-Type\"] = \"application/json\";\n    return defaultHeaders;\n  }\n\n  async timer(seconds): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n  }\n\n  customErrorForResponse(\n    response: AxiosResponse,\n    messageFromServer: string,\n  ): TypesenseError {\n    let errorMessage = `Request failed with HTTP code ${response.status}`;\n    if (\n      typeof messageFromServer === \"string\" &&\n      messageFromServer.trim() !== \"\"\n    ) {\n      errorMessage += ` | Server said: ${messageFromServer}`;\n    }\n\n    let error = new TypesenseError(errorMessage);\n\n    if (response.status === 400) {\n      error = new RequestMalformed(errorMessage);\n    } else if (response.status === 401) {\n      error = new RequestUnauthorized(errorMessage);\n    } else if (response.status === 404) {\n      error = new ObjectNotFound(errorMessage);\n    } else if (response.status === 409) {\n      error = new ObjectAlreadyExists(errorMessage);\n    } else if (response.status === 422) {\n      error = new ObjectUnprocessable(errorMessage);\n    } else if (response.status >= 500 && response.status <= 599) {\n      error = new ServerError(errorMessage);\n    } else {\n      error = new HTTPError(errorMessage);\n    }\n\n    error.httpStatus = response.status;\n\n    return error;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport { CollectionFieldSchema, CollectionSchema } from \"./Collection\";\n\nexport interface CollectionCreateSchema {\n  name: string;\n  default_sorting_field?: string;\n  fields?: CollectionFieldSchema[];\n  symbols_to_index?: string[];\n  token_separators?: string[];\n  enable_nested_fields?: boolean;\n  metadata?: object;\n  voice_query_model?: {\n    model_name?: string;\n  };\n}\n\nexport interface CollectionCreateOptions {\n  src_name?: string;\n}\n\nexport interface CollectionsRetrieveOptions {\n  exclude_fields?: string;\n}\n\nconst RESOURCEPATH = \"/collections\";\n\nexport default class Collections {\n  constructor(private apiCall: ApiCall) {}\n\n  async create(\n    schema: CollectionCreateSchema,\n    options: CollectionCreateOptions = {},\n  ): Promise<CollectionSchema> {\n    return this.apiCall.post<CollectionSchema>(RESOURCEPATH, schema, options);\n  }\n\n  async retrieve(\n    options: CollectionsRetrieveOptions = {},\n  ): Promise<CollectionSchema[]> {\n    return this.apiCall.get<CollectionSchema[]>(RESOURCEPATH, options);\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","const defaultCacheResponseForSeconds = 2 * 60;\nconst defaultMaxSize = 100;\n\nexport default class RequestWithCache {\n  private responseCache: Map<string, any> = new Map<string, any>();\n  private responsePromiseCache: Map<string, any> = new Map<string, any>();\n\n  clearCache() {\n    this.responseCache = new Map<string, any>();\n    this.responsePromiseCache = new Map<string, any>();\n  }\n\n  // Todo: should probably be passed a callback instead, or an apiCall instance. Types are messy this way\n  async perform<T>(\n    requestContext: any,\n    requestFunction: (...params: any) => unknown,\n    requestFunctionArguments: any[],\n    cacheOptions: CacheOptions\n  ): Promise<T | unknown> {\n    const {\n      cacheResponseForSeconds = defaultCacheResponseForSeconds,\n      maxSize = defaultMaxSize,\n    } = cacheOptions;\n    const isCacheDisabled = cacheResponseForSeconds <= 0 || maxSize <= 0;\n\n    if (isCacheDisabled) {\n      return requestFunction.call(requestContext, ...requestFunctionArguments);\n    }\n\n    const requestFunctionArgumentsJSON = JSON.stringify(\n      requestFunctionArguments\n    );\n    const cacheEntry = this.responseCache.get(requestFunctionArgumentsJSON);\n    const now = Date.now();\n\n    if (cacheEntry) {\n      const isEntryValid =\n        now - cacheEntry.requestTimestamp < cacheResponseForSeconds * 1000;\n      if (isEntryValid) {\n        this.responseCache.delete(requestFunctionArgumentsJSON);\n        this.responseCache.set(requestFunctionArgumentsJSON, cacheEntry);\n        return Promise.resolve(cacheEntry.response);\n      } else {\n        this.responseCache.delete(requestFunctionArgumentsJSON);\n      }\n    }\n\n    const cachePromiseEntry = this.responsePromiseCache.get(\n      requestFunctionArgumentsJSON\n    );\n\n    if (cachePromiseEntry) {\n      const isEntryValid =\n        now - cachePromiseEntry.requestTimestamp <\n        cacheResponseForSeconds * 1000;\n      if (isEntryValid) {\n        this.responsePromiseCache.delete(requestFunctionArgumentsJSON);\n        this.responsePromiseCache.set(\n          requestFunctionArgumentsJSON,\n          cachePromiseEntry\n        );\n        return cachePromiseEntry.responsePromise;\n      } else {\n        this.responsePromiseCache.delete(requestFunctionArgumentsJSON);\n      }\n    }\n\n    const responsePromise = requestFunction.call(\n      requestContext,\n      ...requestFunctionArguments\n    );\n    this.responsePromiseCache.set(requestFunctionArgumentsJSON, {\n      requestTimestamp: now,\n      responsePromise,\n    });\n\n    const response = await responsePromise;\n    this.responseCache.set(requestFunctionArgumentsJSON, {\n      requestTimestamp: now,\n      response,\n    });\n\n    const isCacheOverMaxSize = this.responseCache.size > maxSize;\n    if (isCacheOverMaxSize) {\n      const oldestEntry = this.responseCache.keys().next().value;\n      this.responseCache.delete(oldestEntry);\n    }\n    const isResponsePromiseCacheOverMaxSize =\n      this.responsePromiseCache.size > maxSize;\n    if (isResponsePromiseCacheOverMaxSize) {\n      const oldestEntry = this.responsePromiseCache.keys().next().value;\n      this.responsePromiseCache.delete(oldestEntry);\n    }\n    return response as T;\n  }\n}\n\ninterface CacheOptions {\n  cacheResponseForSeconds?: number;\n  maxSize?: number;\n}\n","import RequestWithCache from \"./RequestWithCache\";\nimport ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport Collections from \"./Collections\";\nimport type {\n  DocumentSchema,\n  SearchableDocuments,\n  SearchOptions,\n  SearchParams,\n  SearchParamsWithPreset,\n  SearchResponse,\n} from \"./Documents\";\n\nconst RESOURCEPATH = \"/documents\";\n\nexport class SearchOnlyDocuments<T extends DocumentSchema>\n  implements SearchableDocuments<T>\n{\n  protected requestWithCache: RequestWithCache = new RequestWithCache();\n\n  constructor(\n    protected collectionName: string,\n    protected apiCall: ApiCall,\n    protected configuration: Configuration\n  ) {}\n\n  clearCache() {\n    this.requestWithCache.clearCache();\n  }\n\n  async search(\n    searchParameters: SearchParams | SearchParamsWithPreset,\n    {\n      cacheSearchResultsForSeconds = this.configuration\n        .cacheSearchResultsForSeconds,\n      abortSignal = null,\n    }: SearchOptions = {}\n  ): Promise<SearchResponse<T>> {\n    const additionalQueryParams = {};\n    if (this.configuration.useServerSideSearchCache === true) {\n      additionalQueryParams[\"use_cache\"] = true;\n    }\n    for (const key in searchParameters) {\n      if (Array.isArray(searchParameters[key])) {\n        additionalQueryParams[key] = searchParameters[key].join(\",\");\n      }\n    }\n    const queryParams = Object.assign(\n      {},\n      searchParameters,\n      additionalQueryParams\n    );\n\n    return this.requestWithCache.perform(\n      this.apiCall,\n      this.apiCall.get,\n      [this.endpointPath(\"search\"), queryParams, { abortSignal }],\n      {\n        cacheResponseForSeconds: cacheSearchResultsForSeconds,\n      }\n    ) as Promise<SearchResponse<T>>;\n  }\n\n  protected endpointPath(operation?: string) {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import type { ReadStream } from \"fs\";\nimport ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport { ImportError } from \"./Errors\";\nimport { SearchOnlyDocuments } from \"./SearchOnlyDocuments\";\n\n// Todo: use generic to extract filter_by values\nexport interface DeleteQuery {\n  filter_by?: string;\n  batch_size?: number;\n  ignore_not_found?: boolean;\n}\n\nexport interface DeleteResponse {\n  num_deleted: number;\n}\n\ninterface ImportResponseSuccess {\n  success: true;\n}\n\nexport interface ImportResponseFail {\n  success: false;\n  error: string;\n  document: DocumentSchema;\n  code: number;\n}\n\nexport type ImportResponse = ImportResponseSuccess | ImportResponseFail;\n\nexport type DocumentSchema = Record<string, any>;\n\nexport interface SearchParamsWithPreset extends Partial<SearchParams> {\n  preset: string;\n}\n\ntype OperationMode = \"off\" | \"always\" | \"fallback\";\nexport interface SearchParams {\n  // From https://typesense.org/docs/latest/api/documents.html#arguments\n  q?: string;\n  query_by?: string | string[];\n  query_by_weights?: string | number[];\n  prefix?: string | boolean | boolean[]; // default: true\n  filter_by?: string;\n  enable_lazy_filter?: boolean; // default: false\n  sort_by?: string | string[]; // default: text match desc\n  facet_by?: string | string[];\n  max_facet_values?: number;\n  facet_sample_threshold?: number;\n  facet_sample_percent?: number;\n  facet_query?: string;\n  facet_query_num_typos?: number;\n  facet_return_parent?: string;\n  page?: number; // default: 1\n  per_page?: number; // default: 10, max 250\n  group_by?: string | string[];\n  group_limit?: number; // default:\n  group_missing_values?: boolean;\n  include_fields?: string | string[];\n  exclude_fields?: string | string[];\n  highlight_fields?: string | string[]; // default: all queried fields\n  highlight_full_fields?: string | string[]; // default: all fields\n  highlight_affix_num_tokens?: number; // default: 4\n  highlight_start_tag?: string; // default: <mark>\n  highlight_end_tag?: string; // default: </mark>\n  enable_highlight_v1?: boolean;\n  snippet_threshold?: number; // default: 30\n  num_typos?: string | number | number[]; // default: 2\n  min_len_1typo?: number;\n  min_len_2typo?: number;\n  split_join_tokens?: OperationMode;\n  exhaustive_search?: boolean;\n  drop_tokens_threshold?: number; // default: 10\n  typo_tokens_threshold?: number; // default: 100\n  pinned_hits?: string | string[];\n  hidden_hits?: string | string[];\n  limit_hits?: number; // default: no limit\n  pre_segmented_query?: boolean;\n  enable_overrides?: boolean;\n  prioritize_exact_match?: boolean; // default: true\n  prioritize_token_position?: boolean;\n  prioritize_num_matching_fields?: boolean;\n  search_cutoff_ms?: number;\n  use_cache?: boolean;\n  max_candidates?: number;\n  infix?: OperationMode | OperationMode[];\n  preset?: string;\n  text_match_type?: \"max_score\" | \"max_weight\";\n  vector_query?: string;\n  \"x-typesense-api-key\"?: string;\n  \"x-typesense-user-id\"?: string;\n  offset?: number;\n  limit?: number;\n  stopwords?: string;\n  conversation?: boolean;\n  conversation_model_id?: string;\n  conversation_id?: string;\n  voice_query?: string;\n}\n\ntype SearchResponseHighlightObject = {\n  matched_tokens?: string[];\n  snippet?: string;\n  value?: string;\n};\n\nexport type SearchResponseHighlight<T> = T extends string | number\n  ? SearchResponseHighlightObject\n  : {\n      [TAttribute in keyof T]?: SearchResponseHighlight<T[TAttribute]>;\n    };\n\nexport interface SearchResponseHit<T extends DocumentSchema> {\n  curated?: true;\n  highlights?: [\n    {\n      field: keyof T;\n      snippet?: string;\n      value?: string;\n      snippets?: string[];\n      indices?: number[];\n      matched_tokens: string[][] | string[];\n    },\n  ];\n  highlight: SearchResponseHighlight<T>;\n  document: T;\n  text_match: number;\n  text_match_info?: {\n    best_field_score: string; // To prevent scores from being truncated by JSON spec\n    best_field_weight: number;\n    fields_matched: number;\n    score: string; // To prevent scores from being truncated by JSON spec\n    tokens_matched: number;\n  };\n}\n\nexport interface SearchResponseFacetCountSchema<T extends DocumentSchema> {\n  counts: {\n    count: number;\n    highlighted: string;\n    value: string;\n  }[];\n  field_name: keyof T;\n  stats: {\n    avg?: number;\n    max?: number;\n    min?: number;\n    sum?: number;\n  };\n}\n\nexport interface SearchResponseRequestParams {\n  collection_name?: string;\n  q?: string;\n  page?: number;\n  per_page?: number;\n  first_q?: string;\n  voice_query?: {\n    transcribed_query?: string;\n  };\n}\n\n// Todo: we could infer whether this is a grouped response by adding the search params as a generic\nexport interface SearchResponse<T extends DocumentSchema> {\n  facet_counts?: SearchResponseFacetCountSchema<T>[];\n  found: number;\n  found_docs?: number;\n  out_of: number;\n  page: number;\n  request_params: SearchResponseRequestParams;\n  search_time_ms: number;\n  search_cutoff?: boolean;\n  hits?: SearchResponseHit<T>[];\n  grouped_hits?: {\n    group_key: string[];\n    hits: SearchResponseHit<T>[];\n    found?: number;\n  }[];\n  conversation?: {\n    answer: string;\n    conversation_history: {\n      conversation: object[];\n      id: string;\n      last_updated: number;\n      ttl: number;\n    };\n    conversation_id: string;\n    query: string;\n  };\n  error?: string;\n  code?: number;\n}\n\nexport interface DocumentWriteParameters {\n  dirty_values?: \"coerce_or_reject\" | \"coerce_or_drop\" | \"drop\" | \"reject\";\n  action?: \"create\" | \"update\" | \"upsert\" | \"emplace\";\n}\n\nexport interface UpdateByFilterParameters {\n  filter_by?: string;\n}\n\nexport interface UpdateByFilterResponse {\n  num_updated: number;\n}\n\nexport interface DocumentImportParameters extends DocumentWriteParameters {\n  batch_size?: number;\n  return_doc?: boolean;\n  return_id?: boolean;\n}\n\nexport interface DocumentsExportParameters {\n  filter_by?: string;\n  include_fields?: string;\n  exclude_fields?: string;\n}\n\nexport interface SearchableDocuments<T extends DocumentSchema> {\n  search(\n    searchParameters: SearchParams | SearchParamsWithPreset,\n    options: SearchOptions,\n  ): Promise<SearchResponse<T>>;\n  clearCache(): void;\n}\n\nexport interface WriteableDocuments<T> {\n  create(document: T, options: DocumentWriteParameters): Promise<T>;\n  upsert(document: T, options: DocumentWriteParameters): Promise<T>;\n  update(document: T, options: DocumentWriteParameters): Promise<T>;\n  delete(query: DeleteQuery): Promise<DeleteResponse>;\n  import(\n    documents: T[] | string,\n    options: DocumentWriteParameters,\n  ): Promise<string | ImportResponse[]>;\n  export(options: DocumentsExportParameters): Promise<string>;\n}\n\nexport interface SearchOptions {\n  cacheSearchResultsForSeconds?: number;\n  abortSignal?: AbortSignal | null;\n}\n\nconst isNodeJSEnvironment =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nexport default class Documents<T extends DocumentSchema = object>\n  extends SearchOnlyDocuments<T>\n  implements WriteableDocuments<T>\n{\n  constructor(\n    collectionName: string,\n    apiCall: ApiCall,\n    configuration: Configuration,\n  ) {\n    super(collectionName, apiCall, configuration);\n  }\n\n  async create(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(this.endpointPath(), document, options);\n  }\n\n  async upsert(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(\n      this.endpointPath(),\n      document,\n      Object.assign({}, options, { action: \"upsert\" }),\n    );\n  }\n\n  async update(\n    document: T,\n    options: UpdateByFilterParameters,\n  ): Promise<UpdateByFilterResponse>;\n  async update(document: T, options: DocumentWriteParameters): Promise<T>;\n  async update(\n    document: T,\n    options: DocumentWriteParameters | UpdateByFilterParameters = {},\n  ): Promise<UpdateByFilterResponse | T> {\n    if (!document) throw new Error(\"No document provided\");\n\n    if (options[\"filter_by\"] != null) {\n      return this.apiCall.patch<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options),\n      );\n    } else {\n      return this.apiCall.post<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options, { action: \"update\" }),\n      );\n    }\n  }\n\n  async delete(\n    query: DeleteQuery = {} as DeleteQuery,\n  ): Promise<DeleteResponse> {\n    return this.apiCall.delete<DeleteResponse>(this.endpointPath(), query);\n  }\n\n  async createMany(documents: T[], options: DocumentImportParameters = {}) {\n    this.configuration.logger.warn(\n      \"createMany is deprecated and will be removed in a future version. Use import instead, which now takes both an array of documents or a JSONL string of documents\",\n    );\n    return this.import(documents, options);\n  }\n\n  /**\n   * Import a set of documents in a batch.\n   * @param {string|Array} documents - Can be a JSONL string of documents or an array of document objects.\n   * @param options\n   * @return {string|Array} Returns a JSONL string if the input was a JSONL string, otherwise it returns an array of results.\n   */\n  async import(\n    documents: string,\n    options?: DocumentImportParameters,\n  ): Promise<string>;\n  async import(\n    documents: T[],\n    options?: DocumentImportParameters,\n  ): Promise<ImportResponse[]>;\n  async import(\n    documents: T[] | string,\n    options: DocumentImportParameters = {},\n  ): Promise<string | ImportResponse[]> {\n    let documentsInJSONLFormat;\n    if (Array.isArray(documents)) {\n      try {\n        documentsInJSONLFormat = documents\n          .map((document) => JSON.stringify(document))\n          .join(\"\\n\");\n      } catch (error: any) {\n        // if rangeerror, throw custom error message\n        if (\n          error instanceof RangeError &&\n          error.message.includes(\"Too many properties to enumerate\")\n        ) {\n          throw new Error(`${error}\n          It looks like you have reached a Node.js limit that restricts the number of keys in an Object: https://stackoverflow.com/questions/9282869/are-there-limits-to-the-number-of-properties-in-a-javascript-object\n\n          Please try reducing the number of keys in your document, or using CURL to import your data.\n          `);\n        }\n\n        // else, throw the non-range error anyways\n        throw new Error(error);\n      }\n    } else {\n      documentsInJSONLFormat = documents;\n    }\n\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: documentsInJSONLFormat,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    if (Array.isArray(documents)) {\n      const resultsInJSONFormat = resultsInJSONLFormat\n        .split(\"\\n\")\n        .map((r) => JSON.parse(r)) as ImportResponse[];\n      const failedItems = resultsInJSONFormat.filter(\n        (r) => r.success === false,\n      );\n      if (failedItems.length > 0) {\n        throw new ImportError(\n          `${\n            resultsInJSONFormat.length - failedItems.length\n          } documents imported successfully, ${\n            failedItems.length\n          } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n          resultsInJSONFormat,\n        );\n      } else {\n        return resultsInJSONFormat;\n      }\n    } else {\n      return resultsInJSONLFormat as string;\n    }\n  }\n  /**\n   * Imports documents from a NodeJS readable stream of JSONL.\n   */\n  async importStream(\n    readableStream: ReadStream,\n    options: DocumentImportParameters = {},\n  ): Promise<ImportResponse[]> {\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: readableStream,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: isNodeJSEnvironment ? true : false, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    const resultsInJSONFormat = resultsInJSONLFormat\n      .split(\"\\n\")\n      .map((r) => JSON.parse(r)) as ImportResponse[];\n    const failedItems = resultsInJSONFormat.filter((r) => r.success === false);\n    if (failedItems.length > 0) {\n      throw new ImportError(\n        `${\n          resultsInJSONFormat.length - failedItems.length\n        } documents imported successfully, ${\n          failedItems.length\n        } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n        resultsInJSONFormat,\n      );\n    } else {\n      return resultsInJSONFormat;\n    }\n  }\n\n  /**\n   * Returns a JSONL string for all the documents in this collection\n   */\n  async export(options: DocumentsExportParameters = {}): Promise<string> {\n    return this.apiCall.get<string>(this.endpointPath(\"export\"), options);\n  }\n\n  /**\n   * Returns a NodeJS readable stream of JSONL for all the documents in this collection.\n   */\n  async exportStream(\n    options: DocumentsExportParameters = {},\n  ): Promise<ReadStream> {\n    return this.apiCall.get<ReadStream>(this.endpointPath(\"export\"), options, {\n      responseType: \"stream\",\n    });\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport { OverrideSchema } from \"./Override\";\n\nconst RESOURCEPATH = \"/overrides\";\n\nexport interface OverrideRuleQuerySchema {\n  query?: string;\n  match?: \"exact\" | \"contains\";\n}\n\nexport interface OverrideRuleFilterSchema {\n  filter_by?: string;\n}\n\nexport interface OverrideRuleTagsSchema {\n  tags?: string[];\n}\n\nexport interface OverrideCreateSchema {\n  rule: OverrideRuleQuerySchema &\n    OverrideRuleFilterSchema &\n    OverrideRuleTagsSchema;\n  filter_by?: string;\n  sort_by?: string;\n  remove_matched_tokens?: boolean;\n  replace_query?: string;\n  includes?: Array<{\n    id: string;\n    position: number;\n  }>;\n  excludes?: Array<{ id: string }>;\n  filter_curated_hits?: boolean;\n  effective_from_ts?: number;\n  effective_to_ts?: number;\n  stop_processing?: boolean;\n  metadata?: object;\n}\n\nexport interface OverridesRetrieveSchema {\n  overrides: OverrideSchema[];\n}\n\nexport default class Overrides {\n  constructor(\n    private collectionName: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async upsert(\n    overrideId: string,\n    params: OverrideCreateSchema,\n  ): Promise<OverrideSchema> {\n    return this.apiCall.put<OverrideSchema>(\n      this.endpointPath(overrideId),\n      params,\n    );\n  }\n\n  async retrieve(): Promise<OverridesRetrieveSchema> {\n    return this.apiCall.get<OverridesRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${\n      Overrides.RESOURCEPATH\n    }${operation === undefined ? \"\" : \"/\" + operation}`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport Overrides, { OverrideCreateSchema } from \"./Overrides\";\n\nexport interface OverrideSchema extends OverrideCreateSchema {\n  id: string;\n}\n\nexport interface OverrideDeleteSchema {\n  id: string;\n}\n\nexport default class Override {\n  constructor(\n    private collectionName: string,\n    private overrideId: string,\n    private apiCall: ApiCall\n  ) {}\n\n  async retrieve(): Promise<OverrideSchema> {\n    return this.apiCall.get<OverrideSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<OverrideDeleteSchema> {\n    return this.apiCall.delete<OverrideDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${Overrides.RESOURCEPATH}/${this.overrideId}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport { SynonymSchema } from \"./Synonym\";\n\nconst RESOURCEPATH = \"/synonyms\";\n\nexport interface SynonymCreateSchema {\n  synonyms: string[];\n  root?: string;\n  locale?: string;\n  symbols_to_index?: string[];\n}\n\nexport interface SynonymsRetrieveSchema {\n  synonyms: SynonymSchema[];\n}\n\nexport default class Synonyms {\n  constructor(private collectionName: string, private apiCall: ApiCall) {}\n\n  async upsert(\n    synonymId: string,\n    params: SynonymCreateSchema\n  ): Promise<SynonymSchema> {\n    return this.apiCall.put<SynonymSchema>(\n      this.endpointPath(synonymId),\n      params\n    );\n  }\n\n  async retrieve(): Promise<SynonymsRetrieveSchema> {\n    return this.apiCall.get<SynonymsRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string) {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${\n      Synonyms.RESOURCEPATH\n    }${operation === undefined ? \"\" : \"/\" + operation}`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport Synonyms, { SynonymCreateSchema } from \"./Synonyms\";\n\nexport interface SynonymSchema extends SynonymCreateSchema {\n  id: string;\n}\n\nexport interface SynonymDeleteSchema {\n  id: string;\n}\n\nexport default class Synonym {\n  constructor(\n    private collectionName: string,\n    private synonymId: string,\n    private apiCall: ApiCall\n  ) {}\n\n  async retrieve(): Promise<SynonymSchema> {\n    return this.apiCall.get<SynonymSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<SynonymDeleteSchema> {\n    return this.apiCall.delete<SynonymDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${Synonyms.RESOURCEPATH}/${this.synonymId}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport Documents, {\n  DeleteQuery,\n  DocumentSchema,\n  DocumentWriteParameters,\n} from \"./Documents\";\n\nexport class Document<T extends DocumentSchema = object> {\n  constructor(\n    private collectionName: string,\n    private documentId: string,\n    private apiCall: ApiCall\n  ) {}\n\n  async retrieve(): Promise<T> {\n    return this.apiCall.get<T>(this.endpointPath());\n  }\n\n  async delete(options?: DeleteQuery): Promise<T> {\n    return this.apiCall.delete<T>(this.endpointPath(), options);\n  }\n\n  async update(\n    partialDocument: Partial<T>,\n    options: DocumentWriteParameters = {}\n  ): Promise<T> {\n    return this.apiCall.patch<T>(this.endpointPath(), partialDocument, options);\n  }\n\n  private endpointPath(): string {\n    return `${Collections.RESOURCEPATH}/${this.collectionName}${Documents.RESOURCEPATH}/${this.documentId}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Collections, { CollectionCreateSchema } from \"./Collections\";\nimport Documents, { DocumentSchema } from \"./Documents\";\nimport { ObjectNotFound } from \"./Errors\";\nimport Overrides from \"./Overrides\";\nimport Override from \"./Override\";\nimport Synonyms from \"./Synonyms\";\nimport Synonym from \"./Synonym\";\nimport { Document } from \"./Document\";\n\nexport type FieldType =\n  | \"string\"\n  | \"int32\"\n  | \"int64\"\n  | \"float\"\n  | \"bool\"\n  | \"geopoint\"\n  | \"geopoint[]\"\n  | \"string[]\"\n  | \"int32[]\"\n  | \"int64[]\"\n  | \"float[]\"\n  | \"bool[]\"\n  | \"object\"\n  | \"object[]\"\n  | \"auto\"\n  | \"string*\"\n  | \"image\";\n\nexport interface CollectionFieldSchema {\n  name: string;\n  type: FieldType;\n  optional?: boolean;\n  facet?: boolean;\n  index?: boolean;\n  sort?: boolean;\n  locale?: string;\n  infix?: boolean;\n  stem?: boolean;\n  num_dim?: number;\n  store?: boolean;\n  [t: string]: unknown;\n}\n\nexport interface CollectionSchema extends CollectionCreateSchema {\n  created_at: number;\n  num_documents: number;\n  num_memory_shards: number;\n}\n\nexport interface CollectionDropFieldSchema {\n  name: string;\n  drop: true;\n}\n\nexport interface CollectionUpdateSchema\n  extends Partial<Omit<CollectionCreateSchema, \"name\" | \"fields\">> {\n  fields?: (CollectionFieldSchema | CollectionDropFieldSchema)[];\n}\n\nexport default class Collection<T extends DocumentSchema = object> {\n  private readonly _documents: Documents<T>;\n  private individualDocuments: Record<string, Document<T>> = {};\n  private readonly _overrides: Overrides;\n  private individualOverrides: Record<string, Override> = {};\n  private readonly _synonyms: Synonyms;\n  private individualSynonyms: Record<string, Synonym> = {};\n\n  constructor(\n    private readonly name: string,\n    private readonly apiCall: ApiCall,\n    private readonly configuration: any,\n  ) {\n    this.name = name;\n    this.apiCall = apiCall;\n    this.configuration = configuration;\n\n    this._documents = new Documents(\n      this.name,\n      this.apiCall,\n      this.configuration,\n    );\n    this._overrides = new Overrides(this.name, this.apiCall);\n    this._synonyms = new Synonyms(this.name, this.apiCall);\n  }\n\n  async retrieve(): Promise<CollectionSchema> {\n    return this.apiCall.get<CollectionSchema>(this.endpointPath());\n  }\n\n  async update(schema: CollectionUpdateSchema): Promise<CollectionSchema> {\n    return this.apiCall.patch<CollectionSchema>(this.endpointPath(), schema);\n  }\n\n  async delete(): Promise<CollectionSchema> {\n    return this.apiCall.delete<CollectionSchema>(this.endpointPath());\n  }\n\n  async exists(): Promise<boolean> {\n    try {\n      await this.retrieve();\n      return true;\n    } catch (e) {\n      if (e instanceof ObjectNotFound) return false;\n      throw e;\n    }\n  }\n\n  documents(): Documents<T>;\n  documents(documentId: string): Document<T>;\n  documents(documentId?: string): Document<T> | Documents<T> {\n    if (!documentId) {\n      return this._documents;\n    } else {\n      if (this.individualDocuments[documentId] === undefined) {\n        this.individualDocuments[documentId] = new Document(\n          this.name,\n          documentId,\n          this.apiCall,\n        );\n      }\n      return this.individualDocuments[documentId];\n    }\n  }\n\n  overrides(): Overrides;\n  overrides(overrideId: string): Override;\n  overrides(overrideId?: string): Overrides | Override {\n    if (overrideId === undefined) {\n      return this._overrides;\n    } else {\n      if (this.individualOverrides[overrideId] === undefined) {\n        this.individualOverrides[overrideId] = new Override(\n          this.name,\n          overrideId,\n          this.apiCall,\n        );\n      }\n      return this.individualOverrides[overrideId];\n    }\n  }\n\n  synonyms(): Synonyms;\n  synonyms(synonymId: string): Synonym;\n  synonyms(synonymId?: string): Synonyms | Synonym {\n    if (synonymId === undefined) {\n      return this._synonyms;\n    } else {\n      if (this.individualSynonyms[synonymId] === undefined) {\n        this.individualSynonyms[synonymId] = new Synonym(\n          this.name,\n          synonymId,\n          this.apiCall,\n        );\n      }\n      return this.individualSynonyms[synonymId];\n    }\n  }\n\n  private endpointPath(): string {\n    return `${Collections.RESOURCEPATH}/${this.name}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/aliases\";\n\nexport interface CollectionAliasCreateSchema {\n  collection_name: string;\n}\n\nexport interface CollectionAliasSchema extends CollectionAliasCreateSchema {\n  name: string;\n}\n\nexport interface CollectionAliasesResponseSchema {\n  aliases: CollectionAliasSchema[];\n}\n\nexport default class Aliases {\n  constructor(private apiCall: ApiCall) {}\n\n  async upsert(\n    name: string,\n    mapping: CollectionAliasCreateSchema\n  ): Promise<CollectionAliasSchema> {\n    return this.apiCall.put<CollectionAliasSchema>(\n      this.endpointPath(name),\n      mapping\n    );\n  }\n\n  async retrieve(): Promise<CollectionAliasesResponseSchema> {\n    return this.apiCall.get<CollectionAliasesResponseSchema>(RESOURCEPATH);\n  }\n\n  private endpointPath(aliasName): string {\n    return `${Aliases.RESOURCEPATH}/${aliasName}`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n","import Aliases, { CollectionAliasSchema } from \"./Aliases\";\nimport ApiCall from \"./ApiCall\";\n\nexport default class Alias {\n  constructor(private name: string, private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<CollectionAliasSchema> {\n    return this.apiCall.get<CollectionAliasSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<CollectionAliasSchema> {\n    return this.apiCall.delete<CollectionAliasSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Aliases.RESOURCEPATH}/${this.name}`;\n  }\n}\n","import { createHmac } from \"crypto\";\nimport ApiCall from \"./ApiCall\";\nimport { KeyCreateSchema, KeySchema } from \"./Key\";\nimport { SearchParams } from \"./Documents\";\n\nconst RESOURCEPATH = \"/keys\";\n\nexport interface KeysRetrieveSchema {\n  keys: KeySchema[];\n}\n\nexport interface GenerateScopedSearchKeyParams extends Partial<SearchParams> {\n  expires_at?: number;\n  cache_ttl?: number;\n  limit_multi_searches?: number;\n}\n\nexport default class Keys {\n  constructor(private apiCall: ApiCall) {\n    this.apiCall = apiCall;\n  }\n\n  async create(params: KeyCreateSchema): Promise<KeySchema> {\n    return this.apiCall.post<KeySchema>(Keys.RESOURCEPATH, params);\n  }\n\n  async retrieve(): Promise<KeysRetrieveSchema> {\n    return this.apiCall.get<KeysRetrieveSchema>(RESOURCEPATH);\n  }\n\n  generateScopedSearchKey(\n    searchKey: string,\n    parameters: GenerateScopedSearchKeyParams\n  ): string {\n    // Note: only a key generated with the `documents:search` action will be\n    // accepted by the server, when usined with the search endpoint.\n    const paramsJSON = JSON.stringify(parameters);\n    const digest = Buffer.from(\n      createHmac(\"sha256\", searchKey).update(paramsJSON).digest(\"base64\")\n    );\n    const keyPrefix = searchKey.substr(0, 4);\n    const rawScopedKey = `${digest}${keyPrefix}${paramsJSON}`;\n\n    return Buffer.from(rawScopedKey).toString(\"base64\");\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Keys from \"./Keys\";\n\nexport interface KeyCreateSchema {\n  actions: string[];\n  collections: string[];\n  description?: string;\n  value?: string;\n  value_prefix?: string;\n  expires_at?: number;\n}\n\nexport interface KeyDeleteSchema {\n  id: number;\n}\n\nexport interface KeySchema extends KeyCreateSchema {\n  id: number;\n}\n\nexport default class Key {\n  constructor(private id: number, private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<KeySchema> {\n    return this.apiCall.get<KeySchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<KeyDeleteSchema> {\n    return this.apiCall.delete<KeyDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Keys.RESOURCEPATH}/${this.id}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/debug\";\n\nexport interface DebugResponseSchema {\n  state: number;\n  version: string;\n}\n\nexport default class Debug {\n  constructor(private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<DebugResponseSchema> {\n    return this.apiCall.get<DebugResponseSchema>(RESOURCEPATH);\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/metrics.json\";\n\nexport interface MetricsResponse {\n  [key: `system_cpu${number}_active_percentage`]: string;\n  system_cpu_active_percentage: string;\n  system_disk_total_bytes: string;\n  system_disk_used_bytes: string;\n  system_memory_total_bytes: string;\n  system_memory_total_swap_bytes?: string;\n  system_memory_used_bytes: string;\n  system_memory_used_swap_bytes?: string;\n  system_network_received_bytes: string;\n  system_network_sent_bytes: string;\n  typesense_memory_active_bytes: string;\n  typesense_memory_allocated_bytes: string;\n  typesense_memory_fragmentation_ratio: string;\n  typesense_memory_mapped_bytes: string;\n  typesense_memory_metadata_bytes: string;\n  typesense_memory_resident_bytes: string;\n  typesense_memory_retained_bytes: string;\n}\n\nexport default class Metrics {\n  constructor(private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<MetricsResponse> {\n    return this.apiCall.get(RESOURCEPATH);\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/stats.json\";\n\nexport interface EndpointStats {\n  [endpoint: string]: number;\n}\n\nexport interface StatsResponse {\n  delete_latency_ms?: number;\n  delete_requests_per_second?: number;\n  import_latency_ms?: number;\n  import_requests_per_second?: number;\n  latency_ms?: EndpointStats;\n  overloaded_requests_per_second?: number;\n  pending_write_batches?: number;\n  requests_per_second?: EndpointStats;\n  search_latency_ms?: number;\n  search_requests_per_second?: number;\n  total_requests_per_second?: number;\n  write_latency_ms?: number;\n  write_requests_per_second?: number;\n}\n\nexport default class Metrics {\n  constructor(private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<StatsResponse> {\n    return this.apiCall.get(RESOURCEPATH);\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/health\";\n\nexport interface HealthResponse {\n  ok: boolean;\n}\n\nexport default class Health {\n  constructor(private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<HealthResponse> {\n    return this.apiCall.get<HealthResponse>(RESOURCEPATH);\n  }\n}\n","import ApiCall from \"./ApiCall\";\n\nconst RESOURCEPATH = \"/operations\";\n\nexport default class Operations {\n  constructor(private apiCall: ApiCall) {}\n\n  async perform(\n    operationName: \"vote\" | \"snapshot\" | \"cache/clear\" | string,\n    queryParameters: Record<string, any> = {}\n  ): Promise<any> {\n    return this.apiCall.post(\n      `${RESOURCEPATH}/${operationName}`,\n      {},\n      queryParameters\n    );\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport RequestWithCache from \"./RequestWithCache\";\nimport {\n  DocumentSchema,\n  SearchParams,\n  SearchParamsWithPreset,\n  SearchResponse,\n} from \"./Documents\";\n\nconst RESOURCEPATH = \"/multi_search\";\n\nexport interface MultiSearchRequestSchema extends SearchParams {\n  collection?: string;\n  \"x-typesense-api-key\"?: string;\n}\n\nexport interface MultiSearchRequestWithPresetSchema\n  extends SearchParamsWithPreset {\n  collection?: string;\n  \"x-typesense-api-key\"?: string;\n}\n\nexport interface MultiSearchRequestsSchema {\n  searches: (MultiSearchRequestSchema | MultiSearchRequestWithPresetSchema)[];\n}\n\nexport interface MultiSearchResponse<T extends DocumentSchema[] = []> {\n  results: { [Index in keyof T]: SearchResponse<T[Index]> } & {\n    length: T[\"length\"];\n  };\n}\n\nexport default class MultiSearch {\n  private requestWithCache: RequestWithCache;\n\n  constructor(\n    private apiCall: ApiCall,\n    private configuration: Configuration,\n    private useTextContentType: boolean = false\n  ) {\n    this.requestWithCache = new RequestWithCache();\n  }\n\n  clearCache() {\n    this.requestWithCache.clearCache();\n  }\n\n  async perform<T extends DocumentSchema[] = []>(\n    searchRequests: MultiSearchRequestsSchema,\n    commonParams: Partial<MultiSearchRequestSchema> = {},\n    {\n      cacheSearchResultsForSeconds = this.configuration\n        .cacheSearchResultsForSeconds,\n    }: { cacheSearchResultsForSeconds?: number } = {}\n  ): Promise<MultiSearchResponse<T>> {\n    const additionalHeaders = {};\n    if (this.useTextContentType) {\n      additionalHeaders[\"content-type\"] = \"text/plain\";\n    }\n\n    const additionalQueryParams = {};\n    if (this.configuration.useServerSideSearchCache === true) {\n      additionalQueryParams[\"use_cache\"] = true;\n    }\n    const queryParams = Object.assign({}, commonParams, additionalQueryParams);\n\n    return this.requestWithCache.perform(\n      this.apiCall,\n      this.apiCall.post,\n      [RESOURCEPATH, searchRequests, queryParams, additionalHeaders],\n      { cacheResponseForSeconds: cacheSearchResultsForSeconds }\n    ) as Promise<MultiSearchResponse<T>>;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport { PresetSchema } from \"./Preset\";\nimport { SearchParams } from \"./Documents\";\nimport { MultiSearchRequestsSchema } from \"./MultiSearch\";\n\nconst RESOURCEPATH = \"/presets\";\n\nexport interface PresetCreateSchema {\n  value: SearchParams | MultiSearchRequestsSchema;\n}\n\nexport interface PresetsRetrieveSchema {\n  presets: PresetSchema[];\n}\n\nexport default class Presets {\n  constructor(private apiCall: ApiCall) {}\n\n  async upsert(\n    presetId: string,\n    params: PresetCreateSchema\n  ): Promise<PresetSchema> {\n    return this.apiCall.put<PresetSchema>(this.endpointPath(presetId), params);\n  }\n\n  async retrieve(): Promise<PresetsRetrieveSchema> {\n    return this.apiCall.get<PresetsRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${Presets.RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Presets, { PresetCreateSchema } from \"./Presets\";\n\nexport interface PresetSchema extends PresetCreateSchema {\n  name: string;\n}\n\nexport interface PresetDeleteSchema {\n  name: string;\n}\n\nexport default class Preset {\n  constructor(private presetId: string, private apiCall: ApiCall) {}\n\n  async retrieve(): Promise<PresetSchema> {\n    return this.apiCall.get<PresetSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<PresetDeleteSchema> {\n    return this.apiCall.delete<PresetDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Presets.RESOURCEPATH}/${this.presetId}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport {\n  AnalyticsRuleCreateSchema,\n  AnalyticsRuleSchema,\n} from \"./AnalyticsRule\";\n\nexport interface AnalyticsRulesRetrieveSchema {\n  rules: AnalyticsRuleSchema[];\n}\n\nconst RESOURCEPATH = \"/analytics/rules\";\n\nexport default class AnalyticsRules {\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n  }\n\n  async upsert(\n    name: string,\n    params: AnalyticsRuleCreateSchema\n  ): Promise<AnalyticsRuleCreateSchema> {\n    return this.apiCall.put<AnalyticsRuleCreateSchema>(\n      this.endpointPath(name),\n      params\n    );\n  }\n\n  async retrieve(): Promise<AnalyticsRulesRetrieveSchema> {\n    return this.apiCall.get<AnalyticsRulesRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${AnalyticsRules.RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport AnalyticsRules from \"./AnalyticsRules\";\n\nexport interface AnalyticsRuleCreateSchema {\n  type: \"popular_queries\" | \"nohits_queries\" | \"counter\";\n  params: {\n    source: {\n      collections: string[];\n      events?: Array<{\n        type: string;\n        weight: number;\n        name: string;\n      }>;\n    };\n    expand_query?: boolean;\n    destination: {\n      collection: string;\n      counter_field?: string;\n    };\n    limit?: number;\n  };\n}\n\nexport interface AnalyticsRuleDeleteSchema {\n  name: string;\n}\n\nexport interface AnalyticsRuleSchema extends AnalyticsRuleCreateSchema {\n  name: string;\n}\n\nexport default class AnalyticsRule {\n  constructor(\n    private name: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async retrieve(): Promise<AnalyticsRuleSchema> {\n    return this.apiCall.get<AnalyticsRuleSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<AnalyticsRuleDeleteSchema> {\n    return this.apiCall.delete<AnalyticsRuleDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${AnalyticsRules.RESOURCEPATH}/${this.name}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport { AnalyticsEventCreateSchema } from \"./AnalyticsEvent\";\n\nconst RESOURCEPATH = \"/analytics/events\";\n\nexport default class AnalyticsEvents {\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n  }\n\n  async create(\n    params: AnalyticsEventCreateSchema,\n  ): Promise<AnalyticsEventCreateSchema> {\n    return this.apiCall.post<AnalyticsEventCreateSchema>(\n      this.endpointPath(),\n      params,\n    );\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${AnalyticsEvents.RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport AnalyticsRules from \"./AnalyticsRules\";\nimport AnalyticsRule from \"./AnalyticsRule\";\nimport AnalyticsEvents from \"./AnalyticsEvents\";\n\nconst RESOURCEPATH = \"/analytics\";\n\nexport default class Analytics {\n  private readonly _analyticsRules: AnalyticsRules;\n  private readonly individualAnalyticsRules: Record<string, AnalyticsRule> = {};\n  private readonly _analyticsEvents: AnalyticsEvents;\n\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n    this._analyticsRules = new AnalyticsRules(this.apiCall);\n    this._analyticsEvents = new AnalyticsEvents(this.apiCall);\n  }\n\n  rules(id?: string): AnalyticsRules | AnalyticsRule {\n    if (id === undefined) {\n      return this._analyticsRules;\n    } else {\n      if (this.individualAnalyticsRules[id] === undefined) {\n        this.individualAnalyticsRules[id] = new AnalyticsRule(id, this.apiCall);\n      }\n      return this.individualAnalyticsRules[id];\n    }\n  }\n\n  events(): AnalyticsEvents {\n    return this._analyticsEvents;\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport { StopwordSchema } from \"./Stopword\";\n\nconst RESOURCEPATH = \"/stopwords\";\n\nexport interface StopwordCreateSchema {\n  stopwords: string[];\n  locale?: string;\n}\n\nexport interface StopwordsRetrieveSchema {\n  stopwords: StopwordSchema[];\n}\n\nexport default class Stopwords {\n  constructor(private apiCall: ApiCall) {}\n\n  async upsert(\n    stopwordId: string,\n    params: StopwordCreateSchema,\n  ): Promise<StopwordSchema> {\n    return this.apiCall.put<StopwordSchema>(\n      this.endpointPath(stopwordId),\n      params,\n    );\n  }\n\n  async retrieve(): Promise<StopwordsRetrieveSchema> {\n    return this.apiCall.get<StopwordsRetrieveSchema>(this.endpointPath());\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${Stopwords.RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH(): string {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Stopwords, { StopwordCreateSchema } from \"./Stopwords\";\n\nexport interface StopwordSchema extends StopwordCreateSchema {\n  id: string;\n  stopwords: string[];\n  locale?: string;\n}\n\nexport interface StopwordDeleteSchema {\n  id: string;\n}\n\nexport default class Stopword {\n  constructor(\n    private stopwordId: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async retrieve(): Promise<StopwordSchema> {\n    return this.apiCall.get<StopwordSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<StopwordDeleteSchema> {\n    return this.apiCall.delete<StopwordDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Stopwords.RESOURCEPATH}/${this.stopwordId}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport {\n  ConversationModelCreateSchema,\n  ConversationModelSchema,\n} from \"./ConversationModel\";\n\nconst RESOURCEPATH = \"/conversations/models\";\n\nexport default class ConversationModels {\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n  }\n\n  async create(\n    params: ConversationModelCreateSchema,\n  ): Promise<ConversationModelCreateSchema> {\n    return this.apiCall.post<ConversationModelCreateSchema>(\n      this.endpointPath(),\n      params,\n    );\n  }\n\n  async retrieve(): Promise<ConversationModelSchema[]> {\n    return this.apiCall.get<ConversationModelSchema[]>(\n      this.endpointPath(),\n    );\n  }\n\n  private endpointPath(operation?: string): string {\n    return `${ConversationModels.RESOURCEPATH}${\n      operation === undefined ? \"\" : \"/\" + operation\n    }`;\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport ConversationModels from \"./ConversationModels\";\n\nexport interface ConversationModelCreateSchema {\n  id?: string;\n  model_name: string;\n  api_key?: string;\n  system_prompt?: string;\n  max_bytes: number;\n  history_collection?: string;\n}\n\nexport interface ConversationModelDeleteSchema {\n  id: string;\n}\n\nexport interface ConversationModelSchema extends ConversationModelCreateSchema {\n  id: string;\n}\n\nexport default class ConversationModel {\n  constructor(\n    private id: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async update(\n    params: ConversationModelCreateSchema,\n  ): Promise<ConversationModelCreateSchema> {\n    return this.apiCall.put<ConversationModelCreateSchema>(\n      this.endpointPath(),\n      params,\n    );\n  }\n\n  async retrieve(): Promise<ConversationModelSchema> {\n    return this.apiCall.get<ConversationModelSchema>(this.endpointPath());\n  }\n\n  async delete(): Promise<ConversationModelDeleteSchema> {\n    return this.apiCall.delete<ConversationModelDeleteSchema>(\n      this.endpointPath(),\n    );\n  }\n\n  private endpointPath(): string {\n    return `${ConversationModels.RESOURCEPATH}/${this.id}`;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport ConversationModels from \"./ConversationModels\";\nimport ConversationModel from \"./ConversationModel\";\nimport { ConversationSchema } from \"./Conversation\";\n\nconst RESOURCEPATH = \"/conversations\";\n\nexport interface ConversationsRetrieveSchema {\n  conversations: ConversationSchema[];\n}\n\nexport default class Conversations {\n  private readonly _conversationsModels: ConversationModels;\n  private readonly individualConversationModels: Record<\n    string,\n    ConversationModel\n  > = {};\n\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n    this._conversationsModels = new ConversationModels(this.apiCall);\n  }\n\n  async retrieve(): Promise<ConversationsRetrieveSchema> {\n    return this.apiCall.get<ConversationsRetrieveSchema>(RESOURCEPATH);\n  }\n\n  models(): ConversationModels;\n  models(id: string): ConversationModel;\n  models(id?: string): ConversationModels | ConversationModel {\n    if (id === undefined) {\n      return this._conversationsModels;\n    } else {\n      if (this.individualConversationModels[id] === undefined) {\n        this.individualConversationModels[id] = new ConversationModel(\n          id,\n          this.apiCall,\n        );\n      }\n      return this.individualConversationModels[id];\n    }\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport Conversations from \"./Conversations\";\n\nexport interface ConversationDeleteSchema {\n  id: number;\n}\n\nexport interface ConversationUpdateSchema {\n  ttl: number;\n}\n\nexport interface ConversationSchema {\n  id: number;\n  conversation: object[];\n  last_updated: number;\n  ttl: number;\n}\n\nexport default class Conversation {\n  constructor(\n    private id: string,\n    private apiCall: ApiCall,\n  ) {}\n\n  async retrieve(): Promise<ConversationSchema[]> {\n    return this.apiCall.get<ConversationSchema[]>(this.endpointPath());\n  }\n\n  async update(\n    params: ConversationUpdateSchema,\n  ): Promise<ConversationUpdateSchema> {\n    return this.apiCall.put<ConversationUpdateSchema>(\n      this.endpointPath(),\n      params,\n    );\n  }\n\n  async delete(): Promise<ConversationDeleteSchema> {\n    return this.apiCall.delete<ConversationDeleteSchema>(this.endpointPath());\n  }\n\n  private endpointPath(): string {\n    return `${Conversations.RESOURCEPATH}/${this.id}`;\n  }\n}\n","/* eslint-disable no-dupe-class-members */\n\nimport Configuration, { ConfigurationOptions } from \"./Configuration\";\nimport ApiCall from \"./ApiCall\";\nimport Collections from \"./Collections\";\nimport Collection from \"./Collection\";\nimport Aliases from \"./Aliases\";\nimport Alias from \"./Alias\";\nimport Keys from \"./Keys\";\nimport Key from \"./Key\";\nimport Debug from \"./Debug\";\nimport Metrics from \"./Metrics\";\nimport Stats from \"./Stats\";\nimport Health from \"./Health\";\nimport Operations from \"./Operations\";\nimport MultiSearch from \"./MultiSearch\";\nimport Presets from \"./Presets\";\nimport Preset from \"./Preset\";\nimport Analytics from \"./Analytics\";\nimport Stopwords from \"./Stopwords\";\nimport Stopword from \"./Stopword\";\nimport Conversations from \"./Conversations\";\nimport Conversation from \"./Conversation\";\n\nexport default class Client {\n  configuration: Configuration;\n  apiCall: ApiCall;\n  debug: Debug;\n  metrics: Metrics;\n  stats: Stats;\n  health: Health;\n  operations: Operations;\n  multiSearch: MultiSearch;\n  analytics: Analytics;\n  private readonly _collections: Collections;\n  private readonly individualCollections: Record<string, Collection>;\n  private readonly _aliases: Aliases;\n  private readonly individualAliases: Record<string, Alias>;\n  private readonly _keys: Keys;\n  private readonly individualKeys: Record<number, Key>;\n  private readonly _presets: Presets;\n  private readonly individualPresets: Record<string, Preset>;\n  private readonly _stopwords: Stopwords;\n  private readonly individualStopwords: Record<string, Stopword>;\n  private readonly _conversations: Conversations;\n  private readonly individualConversations: Record<string, Conversation>;\n\n  constructor(options: ConfigurationOptions) {\n    options.sendApiKeyAsQueryParam = options.sendApiKeyAsQueryParam ?? false;\n\n    this.configuration = new Configuration(options);\n    this.apiCall = new ApiCall(this.configuration);\n    this.debug = new Debug(this.apiCall);\n    this.metrics = new Metrics(this.apiCall);\n    this.stats = new Stats(this.apiCall);\n    this.health = new Health(this.apiCall);\n    this.operations = new Operations(this.apiCall);\n    this.multiSearch = new MultiSearch(this.apiCall, this.configuration);\n    this._collections = new Collections(this.apiCall);\n    this.individualCollections = {};\n    this._aliases = new Aliases(this.apiCall);\n    this.individualAliases = {};\n    this._keys = new Keys(this.apiCall);\n    this.individualKeys = {};\n    this._presets = new Presets(this.apiCall);\n    this.individualPresets = {};\n    this._stopwords = new Stopwords(this.apiCall);\n    this.individualStopwords = {};\n    this.analytics = new Analytics(this.apiCall);\n    this._conversations = new Conversations(this.apiCall);\n    this.individualConversations = {};\n  }\n\n  collections(): Collections;\n  collections<T extends Record<string, any> = object>(\n    collectionName: string,\n  ): Collection<T>;\n  collections(collectionName?: string): Collections | Collection {\n    if (collectionName === undefined) {\n      return this._collections;\n    } else {\n      if (this.individualCollections[collectionName] === undefined) {\n        this.individualCollections[collectionName] = new Collection(\n          collectionName,\n          this.apiCall,\n          this.configuration,\n        );\n      }\n      return this.individualCollections[collectionName];\n    }\n  }\n\n  aliases(): Aliases;\n  aliases(aliasName: string): Alias;\n  aliases(aliasName?: string): Aliases | Alias {\n    if (aliasName === undefined) {\n      return this._aliases;\n    } else {\n      if (this.individualAliases[aliasName] === undefined) {\n        this.individualAliases[aliasName] = new Alias(aliasName, this.apiCall);\n      }\n      return this.individualAliases[aliasName];\n    }\n  }\n\n  keys(): Keys;\n  keys(id: number): Key;\n  keys(id?: number): Keys | Key {\n    if (id === undefined) {\n      return this._keys;\n    } else {\n      if (this.individualKeys[id] === undefined) {\n        this.individualKeys[id] = new Key(id, this.apiCall);\n      }\n      return this.individualKeys[id];\n    }\n  }\n\n  presets(): Presets;\n  presets(id: string): Preset;\n  presets(id?: string): Presets | Preset {\n    if (id === undefined) {\n      return this._presets;\n    } else {\n      if (this.individualPresets[id] === undefined) {\n        this.individualPresets[id] = new Preset(id, this.apiCall);\n      }\n      return this.individualPresets[id];\n    }\n  }\n\n  stopwords(): Stopwords;\n  stopwords(id: string): Stopword;\n  stopwords(id?: string): Stopwords | Stopword {\n    if (id === undefined) {\n      return this._stopwords;\n    } else {\n      if (this.individualStopwords[id] === undefined) {\n        this.individualStopwords[id] = new Stopword(id, this.apiCall);\n      }\n      return this.individualStopwords[id];\n    }\n  }\n\n  conversations(): Conversations;\n  conversations(id: string): Conversation;\n  conversations(id?: string): Conversations | Conversation {\n    if (id === undefined) {\n      return this._conversations;\n    } else {\n      if (this.individualConversations[id] === undefined) {\n        this.individualConversations[id] = new Conversation(id, this.apiCall);\n      }\n      return this.individualConversations[id];\n    }\n  }\n}\n","import { DocumentSchema, SearchableDocuments } from \"./Documents\";\nimport ApiCall from \"./ApiCall\";\nimport { SearchOnlyDocuments } from \"./SearchOnlyDocuments\";\n\nexport class SearchOnlyCollection<T extends DocumentSchema = object> {\n  private readonly _documents: SearchableDocuments<T>;\n\n  constructor(\n    private readonly name: string,\n    private readonly apiCall: ApiCall,\n    private readonly configuration: any\n  ) {\n    this._documents = new SearchOnlyDocuments(\n      this.name,\n      this.apiCall,\n      this.configuration\n    );\n  }\n\n  documents(): SearchableDocuments<T> {\n    return this._documents;\n  }\n}\n","import Configuration, { ConfigurationOptions } from \"./Configuration\";\nimport ApiCall from \"./ApiCall\";\nimport MultiSearch from \"./MultiSearch\";\nimport { DocumentSchema } from \"./Documents\";\nimport { SearchOnlyCollection } from \"./SearchOnlyCollection\";\n\nexport default class SearchClient {\n  public readonly multiSearch: MultiSearch;\n  private readonly configuration: Configuration;\n  private readonly apiCall: ApiCall;\n  private readonly individualCollections: Record<string, SearchOnlyCollection>;\n\n  constructor(options: ConfigurationOptions) {\n    options.sendApiKeyAsQueryParam = options.sendApiKeyAsQueryParam ?? true;\n    if (\n      options.sendApiKeyAsQueryParam === true &&\n      (options.apiKey || \"\").length > 2000\n    ) {\n      console.warn(\n        \"[typesense] API Key is longer than 2000 characters which is over the allowed limit, so disabling sending it as a query parameter.\"\n      );\n      options.sendApiKeyAsQueryParam = false;\n    }\n\n    this.configuration = new Configuration(options);\n    this.apiCall = new ApiCall(this.configuration);\n    this.multiSearch = new MultiSearch(this.apiCall, this.configuration, true);\n    this.individualCollections = {};\n  }\n\n  clearCache() {\n    this.multiSearch.clearCache();\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Object.entries(this.individualCollections).forEach(([_, collection]) => {\n      collection.documents().clearCache();\n    });\n  }\n\n  collections<TDocumentSchema extends DocumentSchema = object>(\n    collectionName: string\n  ): SearchOnlyCollection<TDocumentSchema> | SearchOnlyCollection {\n    if (!collectionName) {\n      throw new Error(\n        \"Typesense.SearchClient only supports search operations, so the collectionName that needs to \" +\n          \"be searched must be specified. Use Typesense.Client if you need to access the collection object.\"\n      );\n    } else {\n      if (this.individualCollections[collectionName] === undefined) {\n        this.individualCollections[collectionName] = new SearchOnlyCollection(\n          collectionName,\n          this.apiCall,\n          this.configuration\n        );\n      }\n      return this.individualCollections[collectionName];\n    }\n  }\n}\n","import Client from \"./Typesense/Client\";\nimport SearchClient from \"./Typesense/SearchClient\";\nimport * as Errors from \"./Typesense/Errors\";\n\nexport { Client, SearchClient, Errors };\nexport default { Client, SearchClient, Errors };\n"],"mappings":"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","names":["logger","Errors_exports","__export","HTTPError","ImportError","MissingConfigurationError","ObjectAlreadyExists","ObjectNotFound","ObjectUnprocessable","RequestMalformed","RequestUnauthorized","ServerError","TypesenseError","TypesenseError","message","HTTPError","TypesenseError","MissingConfigurationError","TypesenseError","ObjectAlreadyExists","TypesenseError","ObjectNotFound","TypesenseError","ObjectUnprocessable","TypesenseError","RequestMalformed","TypesenseError","RequestUnauthorized","TypesenseError","ServerError","TypesenseError","ImportError","TypesenseError","message","importResults","Configuration","options","node","logger","MissingConfigurationError","key","array","i","j","axios","HTTPAgent","HTTPSAgent","APIKEYHEADERNAME","HEALTHY","UNHEALTHY","isNodeJSEnvironment","ApiCall","configuration","endpoint","queryParameters","abortSignal","responseType","bodyParameters","additionalHeaders","requestType","skipConnectionTimeout","enableKeepAlive","requestNumber","lastException","numTries","node","abortListener","requestOptions","status","data","headers","transformedData","source","axios","response","error","candidateNode","i","isDueForHealthcheck","isHealthy","defaultHeaders","seconds","resolve","messageFromServer","errorMessage","TypesenseError","RequestMalformed","RequestUnauthorized","ObjectNotFound","ObjectAlreadyExists","ObjectUnprocessable","ServerError","HTTPError","RESOURCEPATH","Collections","apiCall","schema","options","RequestWithCache","requestContext","requestFunction","requestFunctionArguments","cacheOptions","cacheResponseForSeconds","maxSize","requestFunctionArgumentsJSON","cacheEntry","now","cachePromiseEntry","responsePromise","response","oldestEntry","RESOURCEPATH","SearchOnlyDocuments","collectionName","apiCall","configuration","RequestWithCache","searchParameters","cacheSearchResultsForSeconds","abortSignal","additionalQueryParams","key","queryParams","operation","Collections","isNodeJSEnvironment","Documents","SearchOnlyDocuments","collectionName","apiCall","configuration","document","options","query","documents","documentsInJSONLFormat","error","resultsInJSONLFormat","resultsInJSONFormat","r","failedItems","ImportError","readableStream","RESOURCEPATH","Overrides","_Overrides","collectionName","apiCall","overrideId","params","operation","Collections","Override","collectionName","overrideId","apiCall","Collections","Overrides","RESOURCEPATH","Synonyms","_Synonyms","collectionName","apiCall","synonymId","params","operation","Collections","Synonym","collectionName","synonymId","apiCall","Collections","Synonyms","Document","collectionName","documentId","apiCall","options","partialDocument","Collections","Documents","Collection","name","apiCall","configuration","Documents","Overrides","Synonyms","schema","ObjectNotFound","documentId","Document","overrideId","Override","synonymId","Synonym","Collections","RESOURCEPATH","Aliases","_Aliases","apiCall","name","mapping","aliasName","Alias","name","apiCall","Aliases","createHmac","RESOURCEPATH","Keys","_Keys","apiCall","params","searchKey","parameters","paramsJSON","digest","keyPrefix","rawScopedKey","Key","id","apiCall","Keys","RESOURCEPATH","Debug","apiCall","RESOURCEPATH","Metrics","apiCall","RESOURCEPATH","Metrics","apiCall","RESOURCEPATH","Health","apiCall","RESOURCEPATH","Operations","apiCall","operationName","queryParameters","RESOURCEPATH","MultiSearch","apiCall","configuration","useTextContentType","RequestWithCache","searchRequests","commonParams","cacheSearchResultsForSeconds","additionalHeaders","additionalQueryParams","queryParams","RESOURCEPATH","Presets","_Presets","apiCall","presetId","params","operation","Preset","presetId","apiCall","Presets","RESOURCEPATH","AnalyticsRules","_AnalyticsRules","apiCall","name","params","operation","AnalyticsRule","name","apiCall","AnalyticsRules","RESOURCEPATH","AnalyticsEvents","_AnalyticsEvents","apiCall","params","operation","RESOURCEPATH","Analytics","apiCall","AnalyticsRules","AnalyticsEvents","id","AnalyticsRule","RESOURCEPATH","Stopwords","_Stopwords","apiCall","stopwordId","params","operation","Stopword","stopwordId","apiCall","Stopwords","RESOURCEPATH","ConversationModels","_ConversationModels","apiCall","params","operation","ConversationModel","id","apiCall","params","ConversationModels","RESOURCEPATH","Conversations","apiCall","ConversationModels","id","ConversationModel","Conversation","id","apiCall","params","Conversations","Client","options","Configuration","ApiCall","Debug","Metrics","Health","Operations","MultiSearch","Collections","Aliases","Keys","Presets","Stopwords","Analytics","Conversations","collectionName","Collection","aliasName","Alias","id","Key","Preset","Stopword","Conversation","SearchOnlyCollection","name","apiCall","configuration","SearchOnlyDocuments","SearchClient","options","Configuration","ApiCall","MultiSearch","_","collection","collectionName","SearchOnlyCollection","Typesense_default","Client","SearchClient","Errors_exports"]}